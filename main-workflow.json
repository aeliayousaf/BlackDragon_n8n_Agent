{
  "name": "WhatsApp Lounge Agent - Final",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "whatsapp-webhook",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "1a862e8d-0025-40e1-9125-81fe76b09f38",
      "name": "WhatsApp Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        8528,
        1664
      ],
      "webhookId": "whatsapp-lounge-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Extract phone number and message from WhatsApp webhook\nconst incomingData = $input.item.json;\n\n// DEBUG: Log all keys to see what Twilio sends\nconst allKeys = Object.keys(incomingData);\n\nfunction parseQueryString(s) {\n  try {\n    const str = String(s || '').trim();\n    if (!str) return {};\n    const params = new URLSearchParams(str);\n    const obj = {};\n    for (const [k, v] of params.entries()) obj[k] = v;\n    return obj;\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction extractE164FromAny(v) {\n  const s = (() => {\n    try { return typeof v === 'string' ? v : JSON.stringify(v); } catch (e) { return String(v || ''); }\n  })();\n  // Prefer explicit whatsapp:+E164\n  const m1 = s.match(/whatsapp:\\+(\\d{10,15})/i);\n  if (m1 && m1[1]) return '+' + m1[1];\n  // Otherwise any +E164\n  const m2 = s.match(/\\+(\\d{10,15})/);\n  if (m2 && m2[1]) return '+' + m2[1];\n  // Otherwise digits-only, assume NANP if 10\n  const digits = s.replace(/[^0-9]/g, '');\n  if (digits.length === 10) return '+1' + digits;\n  if (digits.length === 11 && digits.startsWith('1')) return '+' + digits;\n  if (digits.length >= 10 && digits.length <= 15) return '+' + digits;\n  return '';\n}\n\nfunction safeToString(v) {\n  try {\n    if (v === undefined || v === null) return '';\n    if (typeof v === 'string') return v;\n    if (typeof v === 'number' || typeof v === 'boolean' || typeof v === 'bigint') return String(v);\n    if (typeof v === 'object') {\n      if (v && (typeof v.value === 'string' || typeof v.value === 'number' || typeof v.value === 'boolean')) {\n        return String(v.value);\n      }\n      return JSON.stringify(v);\n    }\n    return String(v);\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction pick(obj, keys) {\n  if (!obj || typeof obj !== 'object') return '';\n  for (const k of keys) {\n    if (!(k in obj)) continue;\n    const s = safeToString(obj[k]);\n    if (s && s.trim() !== '') return s;\n  }\n  return '';\n}\n\n// Twilio sends data in different formats depending on content type\n// Try multiple possible field names\nlet phoneNumber = pick(incomingData, ['From', 'WaId', 'from', 'waId']);\n// Prefer sender from nested body (Twilio webhook fields)\ntry {\n  if (incomingData.body && typeof incomingData.body === 'object') {\n    const p = pick(incomingData.body, ['From', 'WaId', 'from', 'waId']);\n    if (p) phoneNumber = p;\n  }\n} catch (e) {}\n\n// Sometimes n8n gives Twilio fields as nested objects/strings; force-extract +E164\nif (!phoneNumber || String(phoneNumber).trim() === '') {\n  // Avoid grabbing the bot number (To); prefer body payload\n  phoneNumber = extractE164FromAny(incomingData.body && typeof incomingData.body === 'object' ? incomingData.body : incomingData);\n}\nelse {\n  const e = extractE164FromAny(phoneNumber);\n  if (e) phoneNumber = e;\n}\n\nlet messageText = '';\n\n// Try to get message from various possible locations\nconst possibleMessage = pick(incomingData, ['Body', 'text', 'Text', 'message', 'Message']);\n\nif (possibleMessage) {\n  if (typeof possibleMessage === 'string') {\n    messageText = possibleMessage;\n  } else if (typeof possibleMessage === 'object') {\n    messageText = pick(possibleMessage, ['Body', 'body', 'text', 'Text']);\n  }\n}\n\n// Check for query parameters (Twilio sometimes sends as form data)\nif ((!messageText || String(messageText).trim() === '') && incomingData.query) {\n  messageText = pick(incomingData.query, ['Body', 'body', 'text', 'Text']) || messageText;\n  phoneNumber = pick(incomingData.query, ['From', 'from', 'WaId', 'waId']) || phoneNumber;\n}\n\n// Check body wrapper as object\nif ((!messageText || String(messageText).trim() === '') && incomingData.body && typeof incomingData.body === 'object') {\n  // Some n8n setups put Twilio fields under incomingData.body\n  messageText = pick(incomingData.body, ['Body', 'body', 'text', 'Text']) || messageText;\n  phoneNumber = pick(incomingData.body, ['From', 'from', 'WaId', 'waId']) || phoneNumber;\n\n  // Sometimes body is nested again\n  if ((!messageText || String(messageText).trim() === '') && incomingData.body.body && typeof incomingData.body.body === 'object') {\n    messageText = pick(incomingData.body.body, ['Body', 'body', 'text', 'Text']) || messageText;\n    phoneNumber = pick(incomingData.body.body, ['From', 'from', 'WaId', 'waId']) || phoneNumber;\n  }\n}\n\n// Check body wrapper as string (application/x-www-form-urlencoded)\nif (incomingData.body && typeof incomingData.body === 'string') {\n  const parsed = parseQueryString(incomingData.body);\n  if (!messageText || String(messageText).trim() === '') {\n    messageText = pick(parsed, ['Body', 'body', 'text', 'Text', 'Message']);\n  }\n  if (!phoneNumber || String(phoneNumber).trim() === '') {\n    phoneNumber = pick(parsed, ['From', 'from', 'WaId', 'waId']);\n  }\n}\n\n// Absolute fallback: regex scan raw payload for a whatsapp:+E164 number\nif (!phoneNumber) {\n  try {\n    const raw = JSON.stringify(incomingData);\n    const m = raw.match(/whatsapp:\\+\\d{10,15}/i);\n    if (m) phoneNumber = m[0];\n  } catch (e) {}\n}\n\n// Ensure messageText is a string\nmessageText = String(messageText || '');\n// If messageText accidentally became JSON, try to extract Body\ntry {\n  const t = messageText.trim();\n  if (t.startsWith('{') && t.endsWith('}')) {\n    const j = JSON.parse(t);\n    const b = (j && (j.Body || j.body || j.text || j.Text)) ? String(j.Body || j.body || j.text || j.Text) : '';\n    if (b) messageText = b;\n    // Also recover sender from the same JSON payload\n    const fromJ = (j && (j.From || j.from || j.WaId || j.waId)) ? String(j.From || j.from || j.WaId || j.waId) : '';\n    if (fromJ && (!phoneNumber || String(phoneNumber).trim() === '')) phoneNumber = fromJ;\n  }\n} catch (e) {}\n\n\n// Clean up phone number\n{\n  const e = extractE164FromAny(phoneNumber);\n  if (e) phoneNumber = e;\n}\nif (phoneNumber) {\n  phoneNumber = String(phoneNumber)\n    .replace('whatsapp:', '')\n    .replace(/\\s|\\n/g, '')\n    .trim();\n}\n\n// Check for quick commands (case-insensitive)\nconst upperMessage = messageText.toUpperCase().trim();\nlet quickCommand = null;\n\nif (upperMessage === 'RENEW') {\n  quickCommand = 'renew';\n} else if (upperMessage === 'CANCEL') {\n  quickCommand = 'cancel';\n}\n\nreturn [{ json: {\n  phoneNumber: phoneNumber,\n  messageText: messageText,\n  quickCommand: quickCommand,\n  timestamp: new Date().toISOString(),\n  _debug_keys: allKeys,\n  _debug_raw: JSON.stringify(incomingData).substring(0, 1200)\n} }];\n"
      },
      "id": "fa336522-b5d5-42b8-940a-bebd0a19a167",
      "name": "Parse Incoming Message",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        8752,
        1664
      ]
    },
    {
      "parameters": {
        "authentication": "airtableTokenApi",
        "operation": "list",
        "application": {
          "__rl": true,
          "value": "app8NRdp0pEHfShoJ",
          "mode": ""
        },
        "table": "Members",
        "additionalOptions": {}
      },
      "id": "51ba0189-b489-4e61-a6d5-1340bb548f09",
      "name": "Airtable: Lookup Member",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 1,
      "position": [
        8960,
        1776
      ],
      "credentials": {
        "airtableTokenApi": {
          "id": "aGJEUsnx6WBz4t50",
          "name": "Lounge Airtable"
        }
      }
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "savedMessageText",
              "value": "={{$json.messageText}}"
            },
            {
              "name": "savedPhoneNumber",
              "value": "={{$json.phoneNumber}}"
            },
            {
              "name": "savedQuickCommand",
              "value": "={{$json.quickCommand}}"
            }
          ]
        },
        "options": {}
      },
      "id": "16b42687-2fc8-4343-a042-4add3201a20f",
      "name": "Save Message Branch",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        8960,
        1536
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "multiplex",
        "options": {}
      },
      "id": "94850a9f-4368-4b32-b63d-df0048ca67f9",
      "name": "Merge Data",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        9184,
        1664
      ]
    },
    {
      "parameters": {},
      "id": "97e75c35-be96-4811-b3e5-c3b947d95320",
      "name": "Merge Lounge Info",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        9424,
        1904
      ]
    },
    {
      "parameters": {
        "functionCode": "// Combine the merged data: original message + Airtable member + Loungeingo info\nconst items = $input.all();\n\nlet savedMessageText = '';\nlet savedPhoneNumber = '';\nlet savedQuickCommand = null;\nlet memberData = null;\n\nfunction normalizeToE164(v) {\n  const s = String(v || '').trim();\n  if (!s) return '';\n\n  // If it already contains +E.164, keep it\n  const m = s.match(/\\+\\d{10,15}/);\n  if (m) return m[0];\n\n  // Otherwise build from digits (assume NANP for 10 digits)\n  const digits = s.replace(/[^0-9]/g, '');\n  if (!digits) return '';\n  if (digits.length === 11 && digits.startsWith('1')) return '+' + digits;\n  if (digits.length === 10) return '+1' + digits;\n  if (digits.length >= 10 && digits.length <= 15) return '+' + digits;\n  return '';\n}\n\n// First pass: capture saved message + phone\nfor (const item of items) {\n  if (item.json && item.json.savedMessageText !== undefined) {\n    savedMessageText = item.json.savedMessageText || '';\n    savedPhoneNumber = item.json.savedPhoneNumber || '';\n    savedQuickCommand = item.json.savedQuickCommand || null;\n  }\n}\n\n// STRICT: must match exact E.164\nconst incomingE164 = normalizeToE164(savedPhoneNumber);\n\n// Second pass: pick the Airtable *member* record that matches the incoming phone.\n// IMPORTANT: This workflow also pulls lounge records; do not treat those as members.\nfor (const item of items) {\n  if (!incomingE164) break;\n  if (item.json && item.json.fields) {\n    const fields = item.json.fields;\n\n    const looksLikeMemberRecord = !!(\n      fields.MembershipStatus !== undefined ||\n      fields.MembershipType !== undefined ||\n      fields.MonthlyGuestCount !== undefined ||\n      fields.TotalLifetimeGuests !== undefined ||\n      fields.PendingTime !== undefined ||\n      fields.PendingGuests !== undefined\n    );\n    if (!looksLikeMemberRecord) continue;\n    const memberE164 = normalizeToE164(fields.PhoneNumber || fields.Phone || fields.Mobile || fields.MobilePhone || '');\n    if (memberE164 && memberE164 === incomingE164) {\n      memberData = item.json;\n      break;\n    }\n  }\n}\n\n// Pull lounge info (best-effort)\n// This Airtable table stores FAQ-style rows: { Category, Question, Answer, IsActive }\nlet loungeInfo = null;\ntry {\n  const rows = [];\n  for (const item of items) {\n    const fields = item && item.json && item.json.fields ? item.json.fields : null;\n    if (!fields || typeof fields !== 'object') continue;\n    if (fields.Category === undefined && fields.Answer === undefined && fields.Question === undefined) continue;\n    rows.push(fields);\n  }\n\n  const isActive = (v) => {\n    if (v === true) return true;\n    if (v === false) return false;\n    const s = String(v ?? '').trim().toLowerCase();\n    if (!s) return true; // treat missing IsActive as active\n    return ['true','yes','1','active'].includes(s);\n  };\n\n  const activeRows = rows.filter((r) => isActive(r.IsActive));\n  const byCategory = {};\n  for (const r of activeRows) {\n    const cat = String(r.Category || '').trim();\n    const ans = String(r.Answer || '').trim();\n    if (!cat || !ans) continue;\n    byCategory[cat.toLowerCase()] = ans;\n  }\n\n  loungeInfo = {\n    // Keep raw rows for debugging/AI context\n    _rows: activeRows,\n    // Standard keys expected by the workflow\n    HoursText: byCategory['hours'] || byCategory['hour'] || byCategory['hours & location'] || '',\n    GuestPolicyText: byCategory['guest policy'] || byCategory['guests'] || byCategory['policy'] || '',\n    CorkageFeeText: byCategory['corkage'] || byCategory['alcohol'] || '',\n    Address: byCategory['address'] || byCategory['location'] || '',\n    Phone: byCategory['phone'] || byCategory['contact'] || '',\n    AmenitiesText: byCategory['amenities'] || byCategory['amenity'] || '',\n  };\n} catch (e) {\n  loungeInfo = null;\n}\n\n// Fallback: direct node reference (older executions)\nif (!loungeInfo) {\n  try {\n    const loungeItems = $('Airtable: Lookup Lounge Info').all() || [];\n    const first = loungeItems[0] ? loungeItems[0].json : null;\n    const fields = first && first.fields ? first.fields : null;\n    loungeInfo = fields || (first || null);\n  } catch (e) {\n    loungeInfo = null;\n  }\n}\n\n\nif (!memberData) {\n  return [{ json: {\n    _memberFound: false,\n    _originalMessage: savedMessageText,\n    _originalPhone: savedPhoneNumber,\n    _quickCommand: savedQuickCommand,\n    loungeInfo,\n  } }];\n}\n\nreturn [{ json: {\n  _memberFound: true,\n  _originalMessage: savedMessageText,\n  _originalPhone: savedPhoneNumber,\n  _quickCommand: savedQuickCommand,\n  id: memberData.id,\n  fields: memberData.fields,\n  loungeInfo,\n} }];"
      },
      "id": "1fae8a57-5399-42b6-8fdb-f64e841f63d4",
      "name": "Check Member Result",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        9408,
        1664
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._memberFound}}"
            }
          ]
        }
      },
      "id": "c4a9b110-599c-4b84-b4fa-e493a4dca9af",
      "name": "Member Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        9632,
        1664
      ]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "responseMessage",
              "value": "={{\"I don't have you registered as a member. Please contact us at \" + ($json.loungeInfo && ($json.loungeInfo.Phone || $json.loungeInfo.PhoneNumber) ? ($json.loungeInfo.Phone || $json.loungeInfo.PhoneNumber) : '(555) 123-4567') + \" to set up your membership.\\n\\nüí∞ Membership Options:\\n‚Ä¢ Monthly: $395.50/month\\n‚Ä¢ 3-Month: $1,412.50 (save $226!)\"}}"
            },
            {
              "name": "action",
              "value": "not_member"
            }
          ]
        },
        "options": {}
      },
      "id": "f873e93e-0188-4055-a70b-4fceebe46d2a",
      "name": "Not Member Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        9840,
        1536
      ]
    },
    {
      "parameters": {
        "functionCode": "// Get member record and original message\nconst data = $input.first().json;\n\nfunction normalizeToE164(raw) {\n  const s = String(raw || '').trim();\n  if (!s) return '';\n  const noPrefix = s.startsWith('whatsapp:') ? s.slice('whatsapp:'.length).trim() : s;\n  const m = noPrefix.match(/\\+\\d{10,15}/);\n  if (m) return m[0];\n  const digits = noPrefix.replace(/[^0-9]/g, '');\n  if (!digits) return '';\n  if (digits.length === 11 && digits.startsWith('1')) return '+' + digits;\n  if (digits.length === 10) return '+1' + digits;\n  if (digits.length >= 10 && digits.length <= 15) return '+' + digits;\n  return '';\n}\n\n// Get original message from the data\nconst originalMessageText = data._originalMessage || '';\nconst quickCommand = data._quickCommand || null;\n\n// Check and reset guest count if new month\nconst today = new Date();\nconst lastReset = data.fields && data.fields.LastResetDate ? new Date(data.fields.LastResetDate) : new Date(0);\n\nlet currentGuestCount = (data.fields && data.fields.MonthlyGuestCount) || 0;\nlet needsReset = false;\n\nif (today.getMonth() !== lastReset.getMonth() || today.getFullYear() !== lastReset.getFullYear()) {\n  currentGuestCount = 0;\n  needsReset = true;\n}\n\nconst freeGuestsRemaining = Math.max(0, 3 - currentGuestCount);\n\n// Calculate membership status\nconst membershipEndDate = data.fields && data.fields.MembershipEndDate ? new Date(data.fields.MembershipEndDate) : new Date();\nconst daysUntilExpiry = Math.ceil((membershipEndDate - today) / (1000 * 60 * 60 * 24));\nconst isExpired = daysUntilExpiry <= 0;\nconst isExpiringSoon = daysUntilExpiry <= 7 && daysUntilExpiry > 0;\n\n// Pricing based on membership type\nconst membershipType = (data.fields && data.fields.MembershipType) || 'Monthly';\nlet renewalPrice, renewalBasePrice, renewalTax;\n\nif (membershipType === '3-Month') {\n  renewalBasePrice = 1250;\n  renewalTax = 162.50;\n  renewalPrice = 1412.50;\n} else {\n  renewalBasePrice = 350;\n  renewalTax = 45.50;\n  renewalPrice = 395.50;\n}\n\n// Get pending visit data from Airtable (for conversation continuity)\nconst pendingGuests = data.fields && data.fields.PendingGuests;\nconst pendingTime = data.fields && data.fields.PendingTime;\nconst pendingAlcohol = data.fields && data.fields.PendingAlcohol;\n\nreturn [{ json: {\n  memberId: data.id,\n  memberName: (data.fields && (data.fields.FullName || data.fields.Name || data.fields.MemberName || data.fields.Member || data.fields.ContactName)) || 'there',\n  phoneNumber: normalizeToE164((data.fields && data.fields.PhoneNumber) || data._originalPhone || data.phoneNumber || ''),\n  _originalPhone: normalizeToE164(data._originalPhone || ''),\n  email: data.fields && data.fields.Email,\n  membershipStatus: (data.fields && data.fields.MembershipStatus) || 'Active',\n  membershipType: membershipType,\n  membershipEndDate: data.fields && data.fields.MembershipEndDate,\n  daysUntilExpiry: daysUntilExpiry,\n  isExpired: isExpired,\n  isExpiringSoon: isExpiringSoon,\n  currentGuestCount: currentGuestCount,\n  freeGuestsRemaining: freeGuestsRemaining,\n  totalLifetimeGuests: (data.fields && data.fields.TotalLifetimeGuests) || 0,\n  needsReset: needsReset,\n  quickCommand: quickCommand,\n  originalMessageText: originalMessageText,\n  renewalPrice: renewalPrice,\n  renewalBasePrice: renewalBasePrice,\n  renewalTax: renewalTax,\n  pendingGuests: pendingGuests,\n  pendingTime: pendingTime,\n  pendingAlcohol: pendingAlcohol,\n  loungeInfo: data.loungeInfo\n} }];\n"
      },
      "id": "5a151c6b-ac82-47cd-8a85-e8956361d195",
      "name": "Process Member Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        9840,
        1776
      ]
    },
    {
      "parameters": {
        "functionCode": "// Check for quick commands and route accordingly\nconst data = $json;\nconst quickCommand = data.quickCommand;\n\nif (quickCommand === 'renew') {\n    return [{ json: { ...data, route: 'renew' } }];\n} else if (quickCommand === 'cancel') {\n    return [{ json: { ...data, route: 'cancel' } }];\n} else {\n    return [{ json: { ...data, route: 'continue' } }];\n}"
      },
      "id": "30f8a1cd-5905-4a14-bab4-9d29ef49860d",
      "name": "Check Quick Command",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        10064,
        1776
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.route}}",
              "value2": "renew"
            }
          ]
        }
      },
      "id": "a5867b0b-686c-481c-82ac-825eb5d816c4",
      "name": "Is RENEW?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        10288,
        1776
      ]
    },
    {
      "parameters": {
        "functionCode": "// Handle RENEW command\nconst member = $json;\n\nconst today = new Date();\nlet newEndDate;\n\nif (member.membershipType === '3-Month') {\n  newEndDate = new Date(today);\n  newEndDate.setMonth(newEndDate.getMonth() + 3);\n} else {\n  newEndDate = new Date(today);\n  newEndDate.setMonth(newEndDate.getMonth() + 1);\n}\n\nconst formattedEndDate = newEndDate.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });\n\nlet message = 'üéâ *Membership Renewal Request*\\n\\n';\nmessage += 'Hi ' + ((member.memberName || 'there').split(' ')[0]) + '!\\n\\n';\nmessage += 'You are renewing your *' + member.membershipType + '* membership.\\n\\n';\nmessage += 'üí∞ *Total: $' + member.renewalPrice.toFixed(2) + '*\\n';\nmessage += '   Base: $' + member.renewalBasePrice.toFixed(2) + '\\n';\nmessage += '   Tax (13%): $' + member.renewalTax.toFixed(2) + '\\n\\n';\nmessage += 'üìÖ New expiry: ' + formattedEndDate + '\\n\\n';\nmessage += 'To complete your renewal:\\n';\nmessage += '‚Ä¢ Pay via e-transfer to: payments@yourlounge.com\\n';\nmessage += '‚Ä¢ Or call us at (555) 123-4567\\n\\n';\nmessage += 'Reply *CONFIRM* once payment is sent!';\n\nreturn [{ json: {\n  ...member,\n  action: 'renewal_request',\n  responseMessage: message,\n  message: message\n} }];"
      },
      "id": "3aa36e0a-f93f-4447-8d2c-0d1008f3db7a",
      "name": "Handle RENEW",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        10496,
        1456
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.route}}",
              "value2": "cancel"
            }
          ]
        }
      },
      "id": "1908537b-9d8f-42b2-9bbc-96e05ec6ef7c",
      "name": "Is CANCEL?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        10512,
        1904
      ]
    },
    {
      "parameters": {
        "functionCode": "// Handle CANCEL command\nconst member = $json;\n\nconst endDate = member.membershipEndDate ? new Date(member.membershipEndDate).toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) : 'your renewal date';\n\nlet message = 'Hi ' + ((member.memberName || 'there').split(' ')[0]) + ',\\n\\n';\nmessage += 'We are sorry to hear you would like to cancel. üò¢\\n\\n';\nmessage += 'Your ' + member.membershipType + ' membership is active until:\\n';\nmessage += 'üìÖ *' + endDate + '*\\n\\n';\nmessage += 'To help us improve, could you share why you are leaving?\\n\\n';\nmessage += 'Reply with:\\n';\nmessage += '‚Ä¢ *CONFIRM CANCEL* to proceed\\n';\nmessage += '‚Ä¢ Or any message to tell us why\\n\\n';\nmessage += 'We would love to have you back anytime! ü•Ç';\n\nreturn [{ json: {\n  action: 'cancel_request',\n  responseMessage: message\n} }];"
      },
      "id": "465860b3-203e-4cf1-9a9e-0f09a2f8de34",
      "name": "Handle CANCEL",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        10720,
        1776
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.membershipStatus}}",
              "operation": "notEqual",
              "value2": "Active"
            }
          ]
        }
      },
      "id": "6973f948-75fa-4bc5-9af8-7de9b14a9770",
      "name": "Is Active?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        10656,
        2064
      ]
    },
    {
      "parameters": {
        "functionCode": "// Handle inactive/expired member\nconst member = $json;\n\nlet message = 'Hi ' + ((member.memberName || 'there').split(' ')[0]) + '! üëã\\n\\n';\n\nif (member.membershipStatus === 'Expired') {\n  message += 'Your membership has expired.\\n\\n';\n  message += 'We would love to have you back!\\n\\n';\n  message += 'üí∞ *Membership Options:*\\n';\n  message += '‚Ä¢ Monthly: $395.50/month\\n';\n  message += '‚Ä¢ 3-Month: $1,412.50 (save $226!)\\n\\n';\n  message += 'Reply *RENEW* to reactivate your membership!';\n} else if (member.membershipStatus === 'Suspended') {\n  message += 'Your membership is currently suspended.\\n\\n';\n  message += 'Please contact us at (555) 123-4567 to resolve this.';\n} else if (member.membershipStatus === 'Cancelled') {\n  message += 'Your membership was cancelled.\\n\\n';\n  message += 'We would love to have you back!\\n\\n';\n  message += 'üí∞ *Membership Options:*\\n';\n  message += '‚Ä¢ Monthly: $395.50/month\\n';\n  message += '‚Ä¢ 3-Month: $1,412.50 (save $226!)\\n\\n';\n  message += 'Reply *RENEW* to rejoin!';\n} else {\n  message += 'Your membership status is: ' + member.membershipStatus + '\\n\\n';\n  message += 'Please contact us at (555) 123-4567 for assistance.';\n}\n\nreturn [{ json: {\n  action: 'inactive_member',\n  responseMessage: message\n} }];"
      },
      "id": "87bd57b2-60eb-440e-ad80-221f3403b568",
      "name": "Handle Inactive Member",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        10944,
        1904
      ]
    },
    {
      "parameters": {
        "functionCode": "// Enhanced Intent Classification with booking status + explicit time support\nconst memberData = $json;\nconst messageText = (memberData.originalMessageText || '').toLowerCase().trim();\n\n// Pending visit state from Airtable\nconst pendingGuests = memberData.pendingGuests;\nconst pendingTime = memberData.pendingTime;\nconst pendingAlcohol = memberData.pendingAlcohol;\n\n// If pendingTime contains a CONFIRMED marker, it represents an upcoming confirmed visit,\n// not an in-progress booking conversation (avoid accidentally continuing a booking).\nconst pendingIsConfirmed = (typeof pendingTime === 'string') && pendingTime.startsWith('CONFIRMED|');\nconst hasPendingVisit = !pendingIsConfirmed && (\n  (pendingGuests !== null && pendingGuests !== undefined) ||\n  (pendingTime !== null && pendingTime !== undefined && String(pendingTime).trim() !== '') ||\n  (pendingAlcohol !== null && pendingAlcohol !== undefined && String(pendingAlcohol).trim() !== '')\n);\n\nlet intent = 'other';\nlet guests = null;\nlet alcohol = null;\nlet timeReference = null;\n\nfunction formatExplicitTime(h, m, ap) {\n  const hh = parseInt(h, 10);\n  const mm = m !== undefined && m !== null ? parseInt(m, 10) : null;\n  const period = String(ap || '').toUpperCase();\n  if (isNaN(hh) || hh < 1 || hh > 12) return null;\n  if (period !== 'AM' && period !== 'PM') return null;\n  if (mm !== null && (isNaN(mm) || mm < 0 || mm > 59)) return null;\n  return (mm !== null ? `${hh}:${String(mm).padStart(2,'0')} ${period}` : `${hh} ${period}`);\n}\n\nfunction getDayKeyword() {\n  if (messageText.includes('tomorrow evening') || /tomorrow.*evening/i.test(messageText)) return 'tomorrow evening';\n  if (messageText.includes('tonight') || /coming.*tonight/i.test(messageText)) return 'tonight';\n  if (messageText.includes('tomorrow') || /coming.*tomorrow/i.test(messageText)) return 'tomorrow';\n  if (messageText.includes('this evening') || /coming.*this evening/i.test(messageText) || /coming.*evening/i.test(messageText)) return 'this evening';\n  if (messageText.includes('today')) return 'today';\n  return null;\n}\n\nfunction getExplicitTime() {\n  const m =\n    messageText.match(/\\b(?:at|around|for)\\s*(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)\\b/i) ||\n    messageText.match(/\\b(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)\\b/i);\n  if (!m) return null;\n  return formatExplicitTime(m[1], m[2], m[3]);\n}\n\nfunction deriveTimeReference(fallback) {\n  const day = getDayKeyword();\n  const t = getExplicitTime();\n  if (day && t) return `${day} ${t}`;\n  if (t) return t;\n  if (day) return day;\n  return fallback || null;\n}\n\nfunction extractGuestAndTimeFromMessage() {\n  // guest count\n  let guestMatch =\n    messageText.match(/with\\s+(\\d+)\\s*(guest|friend|people|person)?s?/i) ||\n    messageText.match(/bring\\s+(\\d+)\\s*(more\\s+)?(guest|friend|people|person)?s?/i) ||\n    messageText.match(/bringing\\s+(\\d+)\\s*(guest|friend|people|person)?s?/i) ||\n    messageText.match(/(\\d+)\\s*(guest|friend|people|person|of us)s?/i) ||\n    messageText.match(/(\\d+)\\s*(guest|friend|person)\\b/i);\n\n  if (guestMatch && guestMatch[1]) {\n    const n = parseInt(guestMatch[1], 10);\n    if (!isNaN(n) && n >= 0 && n <= 50) guests = n;\n  } else if (hasPendingVisit && pendingGuests !== null && pendingGuests !== undefined && !isNaN(Number(pendingGuests))) {\n    guests = Number(pendingGuests);\n  }\n\n  if (\n    /only\\s+(i|me)\\s+(will|am|be)/i.test(messageText) ||\n    /just\\s+(i|me)\\s+(will|am|be)/i.test(messageText) ||\n    messageText.includes('just me') ||\n    messageText.includes('alone') ||\n    messageText.includes('by myself') ||\n    messageText.includes('solo') ||\n    messageText.includes('no guests')\n  ) {\n    guests = 0;\n  }\n\n  // time\n  timeReference = deriveTimeReference(hasPendingVisit && pendingTime ? String(pendingTime) : null);\n}\n\n// --- Intent detection (order matters) ---\n\n// Cancellation\nconst hasCancelKeywords = messageText.includes('cancel') || messageText.includes('cancelled') || messageText.includes('canceled');\nconst hasGuestKeywords = messageText.includes('guest');\nconst hasCancelledPhrase =\n  messageText.includes('guests have cancelled') || messageText.includes('guests have canceled') ||\n  messageText.includes('guests cancelled') || messageText.includes('guests canceled') ||\n  messageText.includes('guest have cancelled') || messageText.includes('guest have canceled');\n\nif (\n  hasCancelledPhrase ||\n  (hasCancelKeywords && hasGuestKeywords) ||\n  /(my\\s+)?(\\d+\\s+)?guests?\\s+(have\\s+)?(cancelled|canceled)/i.test(messageText) ||\n  messageText.includes('cancel visit') || messageText.includes('cancel my visit') ||\n  messageText.includes('cancel booking') || messageText.includes('cancel reservation') ||\n  messageText.includes(\"can't come\") || messageText.includes(\"cannot come\") ||\n  messageText.includes(\"can't make it\") || messageText.includes(\"cannot make it\") ||\n  messageText.includes(\"won't be coming\") || messageText.includes(\"not coming anymore\") ||\n  messageText.includes('nevermind') || messageText.includes('never mind') ||\n  messageText.includes('cancel that') || messageText.includes('scratch that') ||\n  /cancel.*\\b(tonight|today|tomorrow|this evening|this afternoon)\\b/i.test(messageText) ||\n  /i\\s+want\\s+to\\s+cancel/i.test(messageText)\n) {\n  intent = 'cancel_visit';\n}\n// Booking status queries (including time questions)\nelse if (\n  /\\b(do\\s+i\\s+have|do\\s+we\\s+have|is\\s+my|is\\s+our|check|confirm)\\b.*\\b(booking|reservation|booked|visit)\\b/i.test(messageText) ||\n  /\\b(booking|reservation)\\b.*\\b(tonight|this\\s+evening|today|tomorrow)\\b/i.test(messageText) ||\n  /\\bwhat\\s+time\\b.*\\b(booking|reservation|visit)\\b/i.test(messageText) ||\n  /\\btime\\b.*\\bmy\\b.*\\b(booking|reservation|visit)\\b/i.test(messageText)\n) {\n  intent = 'booking_query';\n}\n// Member privacy: never confirm someone else's membership\nelse if (\n  !/\\b(am\\s+i|i\\s*am|i\\s*'m|is\\s+my|my\\s+membership|my\\s+member|my\\s+status|are\\s+you|your\\s+membership|you\\s+a\\s+member)\\b/i.test(messageText) && (\n    /\\b(is|are)\\s+[a-z][a-z'\\-]+(?:\\s+[a-z][a-z'\\-]+){0,3}\\s+(an?\\s+)?members?\\b/i.test(messageText) ||\n    /\\b(is|are)\\s+(he|she|they)\\s+(an?\\s+)?members?\\b/i.test(messageText) ||\n    /\\bwho\\s+(is|are)\\s+(a\\s+)?members?\\b/i.test(messageText) ||\n    /\\blist\\s+(all\\s+)?members\\b/i.test(messageText) ||\n    (/\\bcan\\s+you\\s+(tell|confirm|check)\\b/i.test(messageText) && /\\bmember(ship)?\\b/i.test(messageText) && /\\b(he|she|they|someone|anyone)\\b/i.test(messageText))\n  )\n) {\n  intent = 'member_privacy';\n}\n// Closing / acknowledgement (keep the conversation natural)\nelse if (\n  /\\b(thanks|thank\\s+you|thx|ty|awesome|great|perfect|sounds\\s+good|okay|ok|got\\s+it|see\\s+you|cya|see\\s+ya)\\b/i.test(messageText) &&\n  messageText.length <= 80\n) {\n  intent = 'closing';\n}\n// Greetings\nelse if (messageText.length === 0) {\n  intent = 'greeting';\n} else if (/^(hi|hello|hey|good morning|good afternoon|good evening|howdy|yo|sup|hiya|greetings)[!?.,\\s]*$/i.test(messageText)) {\n  intent = 'greeting';\n} else if (messageText.length < 4 && !/\\d/.test(messageText)) {\n  intent = 'greeting';\n}\n// Confirm cancel MEMBERSHIP\nelse if (messageText.includes('confirm cancel') || messageText.includes('confirm cancellation') || messageText === 'yes cancel') {\n  intent = 'confirm_cancel';\n}\n\n// Alcohol-only response (high priority, but don't override cancel/booking_query)\nconst hasPurchasePattern =\n  /will.*purchase|will.*buy|purchase.*bar|buy.*bar|purchase.*fro|buy.*fro|purchase.*from|buy.*from|purchase.*at|buy.*at|purchasing.*bar|buying.*bar/i.test(messageText) ||\n  (messageText.includes('purchase') && (messageText.includes('bar') || messageText.includes('from') || messageText.includes('fro') || messageText.includes('at'))) ||\n  (messageText.includes('buy') && (messageText.includes('bar') || messageText.includes('from') || messageText.includes('fro') || messageText.includes('at')));\n\nconst hasBringOwnPattern =\n  /bring.*own|bringing.*own|my own|own.*alcohol|own.*bottle/i.test(messageText) ||\n  (messageText.includes('bring') && (messageText.includes('own') || messageText.includes('bottle') || messageText.includes('wine') || messageText.includes('alcohol')));\n\nif (intent !== 'cancel_visit' && intent !== 'booking_query' && (\n  (hasPendingVisit && (pendingAlcohol === null || pendingAlcohol === undefined || pendingAlcohol === '')) ||\n  hasPurchasePattern || hasBringOwnPattern\n)) {\n  if (hasBringOwnPattern) {\n    intent = 'visit';\n    alcohol = 'own';\n    extractGuestAndTimeFromMessage();\n  } else if (hasPurchasePattern) {\n    intent = 'visit';\n    alcohol = 'purchase';\n    extractGuestAndTimeFromMessage();\n  }\n}\n\n// Guest count query\nif (intent === 'other' && /(how many|how much|how many guests|guests left|guests remaining|guest count|free guests)/i.test(messageText)) {\n  intent = 'guest_count_query';\n}\n// Membership expiry query (avoid routing to hours due to the word \"when\")\nelse if (intent === 'other' && (messageText.includes('expire') || messageText.includes('expiry') || messageText.includes('expires')) && (messageText.includes('membership') || messageText.includes('member'))) {\n  intent = 'membership_expiry';\n}\n// Hours query\nelse if (intent === 'other' && /(hour|open|close|closing|when|what time|is.*open|are you open)/i.test(messageText)) {\n  intent = 'hours_query';\n}\n// Policy\nelse if (intent === 'other' && (messageText.includes('policy') || messageText.includes('rule') || messageText.includes('fee') ||\n  messageText.includes('corkage') || messageText.includes('cost') || messageText.includes('price') ||\n  messageText.includes('charge') || messageText.includes('how much') || messageText.includes('pay') ||\n  messageText.includes('guest limit') || messageText.includes('byob'))) {\n  intent = 'policy';\n}\n// Amenities\nelse if (intent === 'other' && (messageText.includes('amenity') || messageText.includes('amenities') || messageText.includes('facilities') ||\n  messageText.includes('what do you have') || messageText.includes('what do you offer') ||\n  messageText.includes('services') || messageText.includes('features') || messageText.includes('patio') ||\n  messageText.includes('wifi') || messageText.includes('parking') || messageText.includes('food'))) {\n  intent = 'amenities';\n}\n// Contact/location\nelse if (intent === 'other' && (messageText.includes('address') || messageText.includes('location') || messageText.includes('where are') ||\n  messageText.includes('phone') || messageText.includes('contact') || messageText.includes('direction') ||\n  messageText.includes('find you') || messageText.includes('located') || messageText.includes('get there') ||\n  messageText.includes('map') || messageText.includes('street'))) {\n  intent = 'contact';\n}\n// Membership info\nelse if (intent === 'other' && (messageText.includes('membership') || messageText.includes('member') || messageText.includes('join') ||\n  messageText.includes('sign up') || messageText.includes('renewal') || messageText.includes('subscribe') ||\n  messageText.includes('pricing') || messageText.includes('plans') ||\n  messageText.includes('how to become') || messageText.includes('register'))) {\n  intent = 'membership';\n}\n\n// If we have a pending visit waiting for guest count, accept a bare number (but don't override cancel/booking_query)\nif (intent === 'other' && hasPendingVisit && (pendingGuests === null || pendingGuests === undefined) && (\n  /^(\\d+)\\s*(guest|friend|people|person)?s?[!?.,\\s]*$/i.test(messageText) ||\n  messageText.includes('just me') || messageText.includes('alone') || messageText.includes('by myself') || messageText.includes('solo') ||\n  messageText.includes('no guests')\n)) {\n  intent = 'visit';\n  const m = messageText.match(/^(\\d+)/);\n  guests = m ? parseInt(m[1], 10) : 0;\n  alcohol = pendingAlcohol;\n  timeReference = pendingTime;\n}\n\n// Visit booking intent\nconst hasVisitKeywords =\n  messageText.includes('coming') || messageText.includes('visit') || messageText.includes('tonight') ||\n  messageText.includes('tomorrow') || messageText.includes('this evening') || messageText.includes('reservation') ||\n  messageText.includes('book') || messageText.includes('guest') || messageText.includes('friend') ||\n  messageText.includes('people') || messageText.includes('table') || messageText.includes('stop by') ||\n  messageText.includes('drop by') || messageText.includes('swing by') || messageText.includes('come in') ||\n  messageText.includes('this weekend') || messageText.includes('saturday') || messageText.includes('friday') ||\n  messageText.includes('want to come') || messageText.includes('wanna come') || /want.*come/i.test(messageText);\n\nif (intent !== 'cancel_visit' && intent !== 'booking_query' && (intent === 'other' || intent === 'visit') && hasVisitKeywords) {\n  intent = 'visit';\n\n  // guest count\n  let gm =\n    messageText.match(/with\\s+(\\d+)\\s*(guest|friend|people|person)?s?/i) ||\n    messageText.match(/bring\\s+(\\d+)\\s*(more\\s+)?(guest|friend|people|person)?s?/i) ||\n    messageText.match(/bringing\\s+(\\d+)\\s*(guest|friend|people|person)?s?/i) ||\n    messageText.match(/(\\d+)\\s*(guest|friend|people|person|of us)s?/i) ||\n    messageText.match(/(\\d+)\\s*(guest|friend|person)\\b/i);\n\n  if (gm && gm[1]) {\n    const n = parseInt(gm[1], 10);\n    if (!isNaN(n) && n >= 0 && n <= 50) guests = n;\n  } else if (\n    /only\\s+(i|me)\\s+(will|am|be)/i.test(messageText) ||\n    /just\\s+(i|me)\\s+(will|am|be)/i.test(messageText) ||\n    messageText.includes('just me') ||\n    messageText.includes('alone') ||\n    messageText.includes('by myself') ||\n    messageText.includes('solo') ||\n    messageText.includes('no guests')\n  ) {\n    guests = 0;\n  }\n\n  // alcohol (if not already determined)\n  if (alcohol === null || alcohol === undefined) {\n    if (hasBringOwnPattern) alcohol = 'own';\n    else if (hasPurchasePattern || messageText.includes('bar')) alcohol = 'purchase';\n  }\n\n  timeReference = deriveTimeReference(timeReference);\n}\n\nreturn [{ json: {\n  ...memberData,\n  intent,\n  guests,\n  alcohol,\n  timeReference,\n  originalMessage: messageText,\n  needsAI: intent === 'other' || intent === 'hours_query' || intent === 'guest_count_query',\n  pendingGuests: memberData.pendingGuests !== undefined ? memberData.pendingGuests : null,\n  pendingTime: memberData.pendingTime || null,\n  pendingAlcohol: memberData.pendingAlcohol || null\n} }];\n"
      },
      "id": "ae664856-58ad-4432-a2ad-7e7c0da6880b",
      "name": "Classify Intent",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        9664,
        2080
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.intent}}",
              "value2": "visit"
            }
          ]
        }
      },
      "id": "66e29bec-5913-429b-977a-dfefccc31a1c",
      "name": "Is Visit?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        10992,
        2064
      ]
    },
    {
      "parameters": {
        "functionCode": "// Process visit booking - FIXED: Monthly guest limit applies to all visits\nconst data = $json;\n\nconst memberName = data.memberName || 'there';\nconst phoneNumber = data.phoneNumber || data._originalPhone || '';\n\nconst pendingIsConfirmed = (typeof data.pendingTime === 'string') && data.pendingTime.startsWith('CONFIRMED|');\n\n\n// CRITICAL FIX: Check pendingGuests FIRST before checking hasGuests\n// This handles the case where user provided alcohol preference but guest count is in pending data\n// Also check if we have pendingTime/pendingAlcohol (indicates pending visit exists)\nlet numberOfGuests = data.guests;\n\n// If guests is null/undefined, try to use pendingGuests\nif ((numberOfGuests === null || numberOfGuests === undefined || isNaN(numberOfGuests))) {\n  // Check if pendingGuests exists and is valid\n  if (!pendingIsConfirmed && data.pendingGuests !== null && data.pendingGuests !== undefined && !isNaN(data.pendingGuests)) {\n    numberOfGuests = data.pendingGuests;\n  }\n  // If we have pendingTime or pendingAlcohol but no pendingGuests, \n  // it means the first message didn't save pendingGuests properly\n  // In this case, we'll ask for guest count below\n}\n\n// Now check if we have all required info\nconst hasGuests = numberOfGuests !== null && numberOfGuests !== undefined && !isNaN(numberOfGuests);\nconst hasAlcohol = data.alcohol !== null && data.alcohol !== undefined;\n\nif (!hasGuests || !hasAlcohol) {\n  let askMessage = 'Hi ' + ((data.memberName || 'there').split(' ')[0]) + '! üëã\\n\\n';\n  \n  if (hasGuests && numberOfGuests > 0) {\n    askMessage += 'Great, ' + numberOfGuests + ' guest(s)';\n    if (data.timeReference) {\n      askMessage += ' for ' + data.timeReference;\n    }\n    askMessage += '!\\n\\n';\n  } else if (hasGuests && numberOfGuests === 0) {\n    askMessage += 'Just yourself';\n    if (data.timeReference) {\n      askMessage += ' for ' + data.timeReference;\n    }\n    askMessage += '!\\n\\n';\n  }\n  \n  if (!hasGuests) {\n    askMessage += 'How many guests will you be bringing?\\n';\n    if (data.freeGuestsRemaining > 0) {\n      askMessage += '_(You have ' + data.freeGuestsRemaining + ' free guest' + (data.freeGuestsRemaining !== 1 ? 's' : '') + ' remaining this month)_\\n\\n';\n    }\n  }\n  \n  if (!hasAlcohol) {\n    askMessage += 'Will you be:\\n';\n    askMessage += '‚Ä¢ Bringing your own alcohol ($30 corkage fee)\\n';\n    askMessage += '‚Ä¢ Purchasing from us (no fee)';\n  }\n  \n  if (data.isExpiringSoon) {\n    askMessage += '\\n\\n‚è∞ _Note: Your membership expires in ' + data.daysUntilExpiry + ' days. Reply RENEW to extend!_';\n  }\n  \n    return [{ json: {\n    action: 'request_info',\n    responseMessage: askMessage,\n    memberId: data.memberId,\n  memberName: memberName,\n  phoneNumber: phoneNumber,\n    memberName: memberName,\n    phoneNumber: phoneNumber,\n    // Save pending data for next message\n    savePendingGuests: hasGuests ? numberOfGuests : null,\n    savePendingTime: data.timeReference || null,\n    savePendingAlcohol: hasAlcohol ? data.alcohol : null,\n    needsPendingUpdate: true\n  } }];\n}\n\n// Calculate fees\n// numberOfGuests is already set above (from data.guests or data.pendingGuests)\n// If we still don't have guests but have alcohol, ask for guest count\nif (numberOfGuests === null || numberOfGuests === undefined || isNaN(numberOfGuests)) {\n  if (data.alcohol) {\n    // No guests and no pending guests, ask for guest count\n        return [{ json: {\n      action: 'request_info',\n      responseMessage: 'Hi ' + ((data.memberName || 'there').split(' ')[0]) + '! üëã\\n\\n' +\n        'I see you want to ' + (data.alcohol === 'own' ? 'bring your own alcohol' : 'purchase from us') + '.\\n\\n' +\n        'How many guests will you be bringing?\\n' +\n        (data.freeGuestsRemaining > 0 ? '_(You have ' + data.freeGuestsRemaining + ' free guest' + (data.freeGuestsRemaining !== 1 ? 's' : '') + ' remaining this month)_' : ''),\n      memberId: data.memberId,\n      memberName: memberName,\n      phoneNumber: phoneNumber,\n      savePendingGuests: null,\n      savePendingTime: data.timeReference || null,\n      savePendingAlcohol: data.alcohol,\n      needsPendingUpdate: true\n    } }];\n  }\n  numberOfGuests = 0; // Default to 0 only if we truly don't have guest info\n}\n\n// Determine visit date from timeReference (for record keeping, not for guest count calculation)\nconst today = new Date();\ntoday.setHours(0, 0, 0, 0);\nconst tomorrow = new Date(today);\ntomorrow.setDate(tomorrow.getDate() + 1);\n\nlet visitDate;\nconst timeRef = (data.timeReference || '').toLowerCase();\nif (timeRef.includes('tomorrow')) {\n  visitDate = tomorrow.toISOString().split('T')[0];\n} else {\n  // Today, tonight, this evening, etc. = today\n  visitDate = today.toISOString().split('T')[0];\n}\n\n// IMPORTANT: Monthly guest limit applies regardless of visit date (today or tomorrow)\n// Use the monthly guest count from data (already calculated in Process Member Data)\nconst FREE_GUEST_LIMIT = 3;\nconst ADDITIONAL_GUEST_FEE = 50;\nconst CORKAGE_FEE = 30;\n\n// Calculate free guests based on MONTHLY limit (not daily)\nconst freeGuestsRemaining = data.freeGuestsRemaining || 0; // This is already calculated monthly\nconst freeGuestsUsed = Math.min(numberOfGuests, freeGuestsRemaining);\nconst paidGuestsCount = Math.max(0, numberOfGuests - freeGuestsRemaining);\nconst guestFee = paidGuestsCount * ADDITIONAL_GUEST_FEE;\n\nconst hasCorkage = data.alcohol === 'own';\nconst corkageFee = hasCorkage ? CORKAGE_FEE : 0;\nconst totalFees = guestFee + corkageFee;\n\n// Update monthly guest count\nconst newGuestCount = data.currentGuestCount + numberOfGuests;\nconst newFreeGuestsRemaining = Math.max(0, FREE_GUEST_LIMIT - newGuestCount);\n\n// Calculate new total lifetime guests\nconst currentLifetimeGuests = data.totalLifetimeGuests || 0;\nconst newTotalLifetimeGuests = currentLifetimeGuests + numberOfGuests;\n\nlet message = '‚úÖ *Booking Confirmed!*\\n\\n';\nmessage += 'üë§ Member: ' + data.memberName + '\\n';\nmessage += 'üë• Guests: ' + numberOfGuests + '\\n';\n\nif (freeGuestsUsed > 0) {\n  message += '   ‚Ä¢ Free guests: ' + freeGuestsUsed + '\\n';\n}\nif (paidGuestsCount > 0) {\n  message += '   ‚Ä¢ Additional guests: ' + paidGuestsCount + ' x $50 = $' + guestFee + '\\n';\n}\n\nmessage += '\\nüçæ Alcohol: ' + (hasCorkage ? 'Bringing own' : 'Purchasing from us') + '\\n';\nif (corkageFee > 0) {\n  message += '   ‚Ä¢ Corkage fee: $' + corkageFee + '\\n';\n}\n\nmessage += '\\nüí∞ *Total Charges: $' + totalFees + '*\\n';\n\n// Show remaining free guests for the month\nif (newFreeGuestsRemaining > 0) {\n  message += '\\nüìä Free guests remaining this month: ' + newFreeGuestsRemaining + '\\n';\n} else {\n  message += '\\n‚ö†Ô∏è You have used all free guests this month. Additional guests are $50 each.\\n';\n}\n\nif (data.isExpiringSoon) {\n  message += '\\n‚è∞ _Your membership expires in ' + data.daysUntilExpiry + ' days. Reply RENEW to extend!_\\n';\n}\n\nmessage += '\\n\\n‚ö†Ô∏è If you need to cancel guests, please message us before your visit time. Cancellations after your visit can\\'t be applied.\\n';\nmessage += '\\nSee you soon! ü•Ç';\n\nreturn [{ json: {\n  action: 'confirm_visit',\n  responseMessage: message,\n  memberId: data.memberId,\n  numberOfGuests: numberOfGuests,\n  freeGuestsUsed: freeGuestsUsed,\n  paidGuestsCount: paidGuestsCount,\n  guestFee: guestFee,\n  alcoholSource: hasCorkage ? 'Own' : 'Purchase',\n  corkageFee: corkageFee,\n  totalFees: totalFees,\n  newMonthlyGuestCount: newGuestCount,\n  newTotalLifetimeGuests: newTotalLifetimeGuests,\n  visitDate: visitDate, // Store actual visit date (today or tomorrow)\n  visitTime: data.timeReference || 'Not specified',\n  // Store upcoming confirmed visit data (for cancellation before visit day)\n  // Format: CONFIRMED|YYYY-MM-DD|<timeReference>\n  savePendingGuests: numberOfGuests,\n  savePendingTime: 'CONFIRMED|' + String(visitDate).slice(0,10) + '|' + (data.timeReference || 'Not specified'),\n  savePendingAlcohol: hasCorkage ? 'Own' : 'Purchase',\n  needsPendingUpdate: true\n} }];\n"
      },
      "id": "f8b6d78e-e5b6-482d-95ad-856904b92364",
      "name": "Process Visit Booking",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        11120,
        1600
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.intent}}",
              "value2": "confirm_cancel"
            }
          ]
        }
      },
      "id": "a6658084-a51d-4553-9756-e52e62b05e59",
      "name": "Is Confirm Cancel?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        11104,
        2384
      ]
    },
    {
      "parameters": {
        "functionCode": "// Handle CONFIRM CANCEL\nconst data = $json;\nconst today = new Date().toISOString().split('T')[0];\n\nconst endDate = data.membershipEndDate ? new Date(data.membershipEndDate).toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) : 'your renewal date';\n\nlet message = 'Your membership cancellation has been processed. üò¢\\n\\n';\nmessage += 'Your access remains valid until:\\n';\nmessage += 'üìÖ *' + endDate + '*\\n\\n';\nmessage += 'We hope to see you again in the future!\\n';\nmessage += 'Reply *RENEW* anytime to rejoin. ü•Ç';\n\nreturn [{ json: {\n  action: 'confirm_cancellation',\n  responseMessage: message,\n  memberId: data.memberId,\n  cancellationDate: today\n} }];"
      },
      "id": "cc1131f8-66bd-4630-9a09-b5d510d3ea5d",
      "name": "Handle Confirm Cancel",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        11600,
        2144
      ]
    },
    {
      "parameters": {
        "functionCode": "// Enhanced FAQ Handler with Dynamic Question Support\nconst data = $json;\nconst intent = data.intent;\nconst messageText = (data.originalMessage || '').toLowerCase();\n\n// Raw hours text from Airtable (used in several hours responses)\nconst hoursTextRaw = String((data.loungeInfo && (data.loungeInfo.HoursText || data.loungeInfo.Hours || data.loungeInfo.hours)) || '').trim();\n\nlet message = '';\nlet clearPendingData = false;\nlet cancelledGuests = 0;\nlet newMonthlyGuestCount = null;\nlet cancellationAllowed = true;\nlet remainingGuests = null;\n\n// Helper function to check if lounge is open today\nfunction getLoungeStatus(dateOverride) {\n  const now = dateOverride ? new Date(dateOverride) : new Date();\n  const dayOfWeek = now.getDay(); // 0=Sunday..6=Saturday\n  const dayNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];\n  const dayName = dayNames[dayOfWeek] || 'Today';\n\n  const lounge = data.loungeInfo || {};\n  const hoursText = lounge.HoursText || lounge.Hours || lounge.hours || '';\n\n  // Attempt to compute open/closed from structured fields if present\n  const openDaysRaw = lounge.OpenDays || lounge.OpenDaysText || lounge.openDays || '';\n  const closedDaysRaw = lounge.ClosedDays || lounge.ClosedDaysText || lounge.closedDays || '';\n  const openTimeRaw = lounge.OpenTime || lounge.OpenTimeText || lounge.openTime || '';\n  const closeTimeRaw = lounge.CloseTime || lounge.CloseTimeText || lounge.closeTime || '';\n\n  const normalizeDays = (v) => {\n    const rawParts = Array.isArray(v)\n      ? v.map(String)\n      : String(v || '').split(/,|\\n|\\|/g);\n\n    const canonical = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];\n\n    const toDay = (s) => {\n      const t = String(s || '').trim().toLowerCase();\n      if (!t) return '';\n      const map = {\n        sun: 'Sunday',\n        sunday: 'Sunday',\n        mon: 'Monday',\n        monday: 'Monday',\n        tue: 'Tuesday',\n        tues: 'Tuesday',\n        tuesday: 'Tuesday',\n        wed: 'Wednesday',\n        weds: 'Wednesday',\n        wednesday: 'Wednesday',\n        thu: 'Thursday',\n        thur: 'Thursday',\n        thurs: 'Thursday',\n        thursday: 'Thursday',\n        fri: 'Friday',\n        friday: 'Friday',\n        sat: 'Saturday',\n        saturday: 'Saturday',\n      };\n      // Strip non-letters so \"Tuesday - closed\" becomes \"tuesday\"\n      const key = t.replace(/[^a-z]/g, '');\n      return map[key] || '';\n    };\n\n    const expandRange = (startDay, endDay) => {\n      const si = canonical.indexOf(startDay);\n      const ei = canonical.indexOf(endDay);\n      if (si === -1 || ei === -1) return [];\n      const out = [];\n      let i = si;\n      while (true) {\n        out.push(canonical[i]);\n        if (i === ei) break;\n        i = (i + 1) % canonical.length;\n        if (out.length > 7) break;\n      }\n      return out;\n    };\n\n    const out = [];\n\n    for (let part of rawParts) {\n      let p = String(part || '')\n        .replace(/[‚Äì‚Äî]/g, '-')\n        .replace(/\\b(closed|open|hours?)\\b/gi, '')\n        .replace(/\\([^)]*\\)/g, '')\n        .replace(/\\b\\d{1,2}(?::\\d{2})?\\s*(am|pm)\\b/gi, '')\n        .replace(/\\bto\\b/gi, ' ')\n        .replace(/[:]/g, ' ')\n        .trim();\n\n      if (!p) continue;\n      p = p.replace(/^and\\s+/i, '').trim();\n      p = p.replace(/-+/g, '-').replace(/^-|-$/g, '').trim();\n      if (!p) continue;\n\n      // Range like \"Sunday-Tuesday\"\n      const rm = p.match(/^(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)\\s*-\\s*(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)$/i);\n      if (rm) {\n        const a = toDay(rm[1]);\n        const b = toDay(rm[2]);\n        out.push(...expandRange(a, b));\n        continue;\n      }\n\n      const d = toDay(p);\n      if (d) out.push(d);\n    }\n\n    return Array.from(new Set(out));\n  };\n\n  const openDays = normalizeDays(openDaysRaw);\n  const closedDays = normalizeDays(closedDaysRaw);\n\n  const parseTimeToMinutes = (v) => {\n    const s = String(v || '').trim().toLowerCase();\n    if (!s) return null;\n    // 19:00\n    const m24 = s.match(/^(\\d{1,2}):(\\d{2})$/);\n    if (m24) return (parseInt(m24[1], 10) * 60) + parseInt(m24[2], 10);\n    // 7pm / 7 pm / 7:00 pm\n    const m12 = s.match(/^(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)$/);\n    if (m12) {\n      let h = parseInt(m12[1], 10);\n      const min = m12[2] ? parseInt(m12[2], 10) : 0;\n      const ap = m12[3];\n      if (ap === 'pm' && h !== 12) h += 12;\n      if (ap === 'am' && h === 12) h = 0;\n      return h * 60 + min;\n    }\n    return null;\n  };\n\n  const formatTime = (minutes) => {\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    const period = hours >= 12 ? 'PM' : 'AM';\n    const displayHour = hours > 12 ? hours - 12 : (hours === 0 ? 12 : hours);\n    return `${displayHour}:${mins.toString().padStart(2, '0')} ${period}`;\n  };\n\n  const openMins = parseTimeToMinutes(openTimeRaw);\n  let closeMins = parseTimeToMinutes(closeTimeRaw);\n  if (closeMins === 0) closeMins = 24 * 60; // treat 12:00 AM as midnight end\n\n  const currentMins = now.getHours() * 60 + now.getMinutes();\n\n  // If no structured schedule exists, we can only use HoursText from Airtable.\n  const deriveScheduleFromHoursText = (htRaw) => {\n    const ht = String(htRaw || '').trim();\n    if (!ht) return { openDays: [], closedDays: [], openMins: null, closeMins: null };\n    const parts = ht.split(/;|\\n/g).map((s) => s.trim()).filter(Boolean);\n    let closed = [];\n    let open = [];\n    let openM = null;\n    let closeM = null;\n    const rangeRe = /(\\d{1,2}(?::\\d{2})?\\s*(?:am|pm))\\s*(?:-|‚Äì|to)\\s*(\\d{1,2}(?::\\d{2})?\\s*(?:am|pm))/i;\n    for (const p of parts) {\n      if (/closed/i.test(p)) {\n        const before = p.split(/closed/i)[0] || p;\n        closed = Array.from(new Set(closed.concat(normalizeDays(before))));\n      }\n      const m = p.match(rangeRe);\n      if (m && m[1] && m[2]) {\n        const beforeOpen = p.split(rangeRe)[0] || p;\n        open = Array.from(new Set(open.concat(normalizeDays(beforeOpen))));\n        if (openM === null) openM = parseTimeToMinutes(m[1]);\n        if (closeM === null) closeM = parseTimeToMinutes(m[2]);\n      }\n    }\n    if (closeM === 0) closeM = 24 * 60;\n    return { openDays: open, closedDays: closed, openMins: openM, closeMins: closeM };\n  };\n\n  if (!openDays.length || openMins === null || closeMins === null) {\n    const derived = deriveScheduleFromHoursText(hoursText);\n    const dClosed = Array.isArray(derived.closedDays) ? derived.closedDays : [];\n    const dOpen = Array.isArray(derived.openDays) ? derived.openDays : [];\n    let dOpenM = derived.openMins;\n    let dCloseM = derived.closeMins;\n    if (dCloseM === 0) dCloseM = 24 * 60;\n\n    const isClosedDay = dClosed.map((d) => String(d).toLowerCase()).includes(dayName.toLowerCase());\n    if (isClosedDay) {\n      return { dayName, hoursText, isOpenDay: false, isOpen: false };\n    }\n\n    const isOpenDay = dOpen.map((d) => String(d).toLowerCase()).includes(dayName.toLowerCase());\n    if (isOpenDay && dOpenM !== null && dCloseM !== null) {\n      const isOpen = currentMins >= dOpenM && currentMins < dCloseM;\n      return {\n        dayName,\n        hoursText,\n        isOpenDay: true,\n        isOpen,\n        openingTime: formatTime(dOpenM),\n        closingTime: formatTime(dCloseM),\n      };\n    }\n\n    return { dayName, hoursText };\n  }\n\n  const isClosedDay = closedDays.map((d) => d.toLowerCase()).includes(dayName.toLowerCase());\n  const isOpenDay = openDays.map((d) => d.toLowerCase()).includes(dayName.toLowerCase()) && !isClosedDay;\n  const isOpen = isOpenDay && currentMins >= openMins && currentMins < closeMins;\n\n  return {\n    dayName,\n    hoursText,\n    isOpenDay,\n    isOpen,\n    openingTime: formatTime(openMins),\n    closingTime: formatTime(closeMins),\n  };\n}\n\nswitch (intent) {\n  case 'closing':\n    // Friendly acknowledgement without starting a new flow\n    {\n      const firstName = ((data.memberName || 'there').split(' ')[0]) || 'there';\n      const pt = String(data.pendingTime || '');\n      if (pt.startsWith('CONFIRMED|')) {\n        const parts = pt.split('|');\n        const dateStr = parts[1] || '';\n        const timeRef = parts[2] || '';\n        const when = [dateStr, timeRef].filter(Boolean).join(' ');\n        message = 'Perfect, ' + firstName + '.\\n\\nSee you ' + (when ? ('for ' + when) : 'soon') + '!';\n      } else {\n        message = 'Perfect, ' + firstName + '.\\n\\nSee you soon!';\n      }\n    }\n    break;\n\n  case 'greeting':\n    message = 'Hi ' + ((data.memberName || 'there').split(' ')[0]) + '! üëã Welcome back!\\n\\n';\n    message += 'How can I help you today?\\n\\n';\n    message += '‚Ä¢ To book a visit, tell me when you are coming and how many guests\\n';\n    message += '‚Ä¢ Ask me about hours, amenities, or policies\\n';\n    message += '‚Ä¢ Reply *RENEW* to renew your membership';\n    break;\n  \n  case 'cancel_visit':\n    // This intent can mean either:\n    // A) cancel the entire visit, OR\n    // B) cancel/reduce guests while the member is still coming.\n    //\n    // If the message explicitly says the member cannot come / cancel the visit, treat it as a VISIT cancellation.\n    // If it says guests cancelled, treat it as a GUESTS-only change (keep the visit confirmed, even if guests become 0).\n\n    const rawMsg = String(data.originalMessage || '').toLowerCase();\n    const explicitVisitCancel =\n      rawMsg.includes('cancel my visit') ||\n      rawMsg.includes('cancel visit') ||\n      rawMsg.includes('cancel my booking') ||\n      rawMsg.includes('cancel booking') ||\n      rawMsg.includes('cancel my reservation') ||\n      rawMsg.includes('cancel reservation') ||\n      rawMsg.includes(\"can't come\") ||\n      rawMsg.includes('cannot come') ||\n      rawMsg.includes(\"can't make it\") ||\n      rawMsg.includes('cannot make it') ||\n      rawMsg.includes(\"won't be coming\") ||\n      rawMsg.includes('not coming anymore') ||\n      rawMsg.includes('i want to cancel') ||\n      rawMsg.includes('cancel coming');\n\n    const guestOnlySignal =\n      rawMsg.includes('guest') && (rawMsg.includes('cancelled') || rawMsg.includes('canceled') || rawMsg.includes('cancelled') || rawMsg.includes('canceled')) ||\n      /\\bguests?\\b\\s+(have\\s+)?(cancelled|canceled)\\b/i.test(rawMsg) ||\n      /(\\d+)\\s+(?:of\\s+my\\s+)?guests?\\b/i.test(rawMsg);\n\n    const cancelMode = explicitVisitCancel ? 'visit' : (guestOnlySignal ? 'guests' : 'visit');\n\n    // Extract number of cancelled guests from message (for guest-mode)\n    let cancelledGuestsFromText = null;\n    let cancelledMatch = rawMsg.match(/(\\d+)\\s+(?:of\\s+my\\s+)?guests?\\b/i);\n    if (!cancelledMatch) {\n      cancelledMatch = rawMsg.match(/(?:my\\s+)?(\\d+)\\s+guests?\\s+(?:have\\s+)?(?:cancelled|canceled)\\b/i);\n    }\n    if (!cancelledMatch) {\n      cancelledMatch = rawMsg.match(/(\\d+)\\s+guests?\\s*(?:cancelled|canceled)\\b/i);\n    }\n    if (cancelledMatch && cancelledMatch[1]) {\n      cancelledGuestsFromText = parseInt(cancelledMatch[1], 10);\n      if (Number.isNaN(cancelledGuestsFromText)) cancelledGuestsFromText = null;\n    }\n\n    const pendingGuestsNumber = (data.pendingGuests !== null && data.pendingGuests !== undefined && !Number.isNaN(Number(data.pendingGuests)))\n      ? Number(data.pendingGuests)\n      : null;\n\n    const hasPendingVisitForCancel =\n      pendingGuestsNumber !== null ||\n      (data.pendingTime && String(data.pendingTime).trim() !== '') ||\n      (data.pendingAlcohol && String(data.pendingAlcohol).trim() !== '');\n\n    // If this is a CONFIRMED marker, only allow changes up until the visit day.\n    let confirmedVisitDateStr = null;\n    if (data.pendingTime && typeof data.pendingTime === 'string' && data.pendingTime.startsWith('CONFIRMED|')) {\n      const parts = String(data.pendingTime).split('|');\n      if (parts.length >= 2) confirmedVisitDateStr = parts[1];\n    }\n\n    if (confirmedVisitDateStr) {\n      const today = new Date();\n      const todayStr = today.toISOString().slice(0, 10);\n      if (confirmedVisitDateStr < todayStr) {\n        cancellationAllowed = false;\n        message = 'Sorry ' + (data.memberName || 'there') + ' ‚Äî it\\'s too late to make changes for a past visit.\\n\\nIf you need to cancel, please message us before your visit time.';\n        break;\n      }\n    }\n\n    if (!hasPendingVisitForCancel) {\n      cancellationAllowed = false;\n      message = 'Got it, ' + (data.memberName || 'there') + ' ‚Äî I don\\'t see an upcoming booking to update right now.\\n\\nIf you already have a booking, tell me how many guests you\\'re cancelling (e.g., \"my 2 guests have cancelled\").';\n      break;\n    }\n\n    // Compute cancelledGuests\n    if (cancelMode === 'visit') {\n      // Whole-visit cancellation: default to cancelling all guests if known\n      cancelledGuests = pendingGuestsNumber !== null ? pendingGuestsNumber : (cancelledGuestsFromText !== null ? cancelledGuestsFromText : 0);\n      clearPendingData = true;\n    } else {\n      // Guests-only: cap by current pending guests; keep booking even if it becomes 0 guests\n      if (cancelledGuestsFromText !== null) {\n        cancelledGuests = cancelledGuestsFromText;\n      } else {\n        cancelledGuests = pendingGuestsNumber !== null ? pendingGuestsNumber : 0;\n      }\n      if (pendingGuestsNumber !== null) {\n        cancelledGuests = Math.min(Math.max(0, cancelledGuests), pendingGuestsNumber);\n        remainingGuests = Math.max(0, pendingGuestsNumber - cancelledGuests);\n      } else {\n        remainingGuests = null;\n      }\n      clearPendingData = false;\n    }\n\n    // Update monthly guest count\n    const currentGuestCount = data.currentGuestCount || 0;\n    newMonthlyGuestCount = Math.max(0, currentGuestCount - (cancelledGuests || 0));\n\n    // Build response message\n    const firstName = ((data.memberName || 'there').split(' ')[0]) || 'there';\n\n    if (cancelMode === 'visit') {\n      message = 'No problem, ' + firstName + '. I\\'ve cancelled your visit.\\n\\n';\n      message += 'Whenever you\\'re ready to book again, just tell me when you\\'d like to come and how many guests you\\'ll have.';\n    } else {\n      // Guests-only change\n      if (cancelledGuests > 0) {\n        message = 'No problem, ' + firstName + '! I\\'ve removed ' + cancelledGuests + ' guest' + (cancelledGuests !== 1 ? 's' : '') + ' from your booking.\\n\\n';\n      } else {\n        // Example: user says \"my 2 guests cancelled\" but booking currently has 0 guests\n        message = 'Got it, ' + firstName + ' ‚Äî it looks like your booking is already set for just you (0 guests).\\n\\n';\n      }\n\n      // Mention what the booking is set for (if confirmed marker exists)\n      const pt = String(data.pendingTime || '');\n      if (pt.startsWith('CONFIRMED|')) {\n        const parts = pt.split('|');\n        const dateStr = parts[1] || '';\n        const timeRef = parts[2] || '';\n        const when = [dateStr, timeRef].filter(Boolean).join(' ');\n        if (when) message += 'You\\'re still confirmed for ' + when + '.\\n\\n';\n      }\n\n      const newFreeGuests = Math.max(0, 3 - newMonthlyGuestCount);\n      message += 'You now have ' + newFreeGuests + ' free guest' + (newFreeGuests !== 1 ? 's' : '') + ' remaining this month.';\n    }\n\n    break;\n\n  case 'hours':\n  case 'hours_query':\n    const isAskingAboutTomorrow = messageText.includes('tomorrow');\n    const tomorrowDate = isAskingAboutTomorrow ? (() => { const d = new Date(); d.setDate(d.getDate() + 1); return d; })() : null;\n    const status = getLoungeStatus(tomorrowDate);\n    const isAskingAboutTonight = !isAskingAboutTomorrow && (\n      messageText.includes('tonight') ||\n      messageText.includes('this evening') ||\n      messageText.match(/open.*tonight/i)\n    );\n    const isAskingAboutToday = !isAskingAboutTomorrow && !isAskingAboutTonight && (\n      messageText.includes('today') ||\n      messageText.includes('now') ||\n      messageText.includes('right now') ||\n      messageText.match(/are you open|is.*open|open\\s+now/i)\n    );\n    const isAskingClosingTime = messageText.includes('close') || messageText.includes('closing') || messageText.includes('what time do you close');\n    const dayWord = isAskingAboutTomorrow ? 'tomorrow' : ((messageText.includes('tonight') || messageText.includes('this evening')) ? 'tonight' : 'today');\n    \n    if (isAskingAboutTomorrow) {\n      if (status.isOpenDay === false) {\n        message = \"No ‚Äî we're closed tomorrow (\" + status.dayName + \").\";\n        if (status.hoursText && String(status.hoursText).trim() !== '') {\n          message += \"\\n\\n\" + String(status.hoursText).trim();\n        }\n      } else if (status.openingTime && status.closingTime) {\n        message = \"Yes ‚Äî we're open tomorrow from \" + status.openingTime + ' to ' + status.closingTime + '.';\n      } else {\n        message = \"Tomorrow's hours: \" + (status.hoursText && String(status.hoursText).trim() !== '' ? String(status.hoursText).trim() : '(Hours not available right now.)');\n      }\n    }\n    else if (isAskingAboutTonight) {\n      // \"Tonight\" questions should be a clear yes/no for tonight (not a full schedule dump)\n      if (status.isOpenDay === false) {\n        message = \"No ‚Äî we're closed tonight (\" + status.dayName + \").\";\n        if (hoursTextRaw) message += \"\\n\\n\" + hoursTextRaw;\n      }\n      else if (status.openingTime && status.closingTime) {\n        if (status.isOpen) {\n          message = \"Yes ‚Äî we're open right now, and we're open until \" + status.closingTime + \" tonight.\";\n        } else {\n          message = \"Yes ‚Äî we're open tonight from \" + status.openingTime + \" to \" + status.closingTime + \".\";\n        }\n      }\n      else {\n        message = \"Yes ‚Äî we're open tonight.\";\n        if (hoursTextRaw) message += \"\\n\\n\" + hoursTextRaw;\n      }\n    }\n\n    else if (isAskingAboutToday) {\n      if (status.isOpen) {\n        message = \"We're open right now.\" + (hoursTextRaw ? (\"\\n\\n\" + hoursTextRaw + \"\\n\\n\") : \"\\n\\n\");\n        if (status.closingTime) {\n          message += 'We are open until ' + status.closingTime + ' today (' + status.dayName + ').\\n\\n';\n        } else if (status.hoursText && String(status.hoursText).trim() !== '') {\n          message += 'Hours today (' + status.dayName + '):\\n' + String(status.hoursText).trim() + '\\n\\n';\n        }\n\n        message += 'See you soon.';\n      } else {\n        message = \"We're closed right now.\" + (hoursTextRaw ? (\"\\n\\n\" + hoursTextRaw + \"\\n\\n\") : \"\\n\\n\");\n        if (status.isOpenDay === false) {\n          message += 'We\\'re closed today (' + status.dayName + ').\\n\\n';\n          if (status.hoursText && String(status.hoursText).trim() !== '') {\n            message += String(status.hoursText).trim();\n          } else {\n            message += 'Please check our hours before coming in.';\n          }\n        } else if (status.openingTime && status.closingTime) {\n          message = \"We're closed right now, but we open at \" + status.openingTime + ' ' + dayWord + ' and close at ' + status.closingTime + '.';\n        }\n        else {\n          if (status.hoursText && String(status.hoursText).trim() !== '') {\n            message += String(status.hoursText).trim();\n          } else {\n            message += 'Hours: (Hours not available right now.)';\n          }\n        }\n      }\n    } else if (isAskingClosingTime) {\n      if (status.closingTime) {\n        message = 'We close at ' + status.closingTime + ' today (' + status.dayName + ').\\n\\n';\n      } else {\n        message = 'Here are our hours:\\n\\n';\n      }\n\n      message += 'üïê *Our Hours:*\\n';\n      if (status.hoursText && String(status.hoursText).trim() !== '') {\n        message += String(status.hoursText).trim();\n      } else {\n        message += 'Hours not available right now.';\n      }\n    } else {\n      message = 'üïê *Our Hours*\\n\\n';\n      if (status.hoursText && String(status.hoursText).trim() !== '') {\n        message += String(status.hoursText).trim() + '\\n\\n';\n      } else {\n        message += 'Hours not available right now.\\n\\n';\n      }\n      message += 'We look forward to seeing you!';\n    if (hoursTextRaw) {\n      message += \"\\n\\n\" + hoursTextRaw;\n    }\n    }\n    break;\n    \n  case 'booking_query':\n    // Check for an upcoming confirmed visit stored in PendingTime\n    const pt = (data.pendingTime || '').toString();\n    const pg = (data.pendingGuests !== null && data.pendingGuests !== undefined && !Number.isNaN(Number(data.pendingGuests)))\n      ? Number(data.pendingGuests)\n      : null;\n    if (pt.startsWith('CONFIRMED|')) {\n      const parts = pt.split('|');\n      const dateStr = parts[1] || '';\n      const timeRef = parts[2] || '';\n      const when = [dateStr, timeRef].filter(Boolean).join(' ');\n      message = \"Yes ‚Äî you're confirmed\" + (when ? (' for ' + when) : '') + (pg !== null ? (' with ' + pg + ' guest' + (pg === 1 ? '' : 's')) : '') + '.';\n    } else {\n      // No confirmed marker: either no booking or an in-progress conversation\n      const hasPending = (pg !== null) || (pt && pt.trim() !== '') || (data.pendingAlcohol && String(data.pendingAlcohol).trim() !== '');\n      if (hasPending) {\n        message = \"I don't see a confirmed booking yet ‚Äî but I do see an in-progress request. Want me to confirm it for you?\";\n      } else {\n        message = \"I don't see a booking for you right now. If you'd like to book, tell me when you're coming and how many guests.\";\n      }\n    }\n    break;\n\n  case 'guest_count_query':\n    const freeGuests = data.freeGuestsRemaining || 0;\n    const usedGuests = data.currentGuestCount || 0;\n    \n    if (freeGuests > 0) {\n      message = 'You have ' + freeGuests + ' free guest' + (freeGuests !== 1 ? 's' : '') + ' remaining this month! üéâ\\n\\n';\n      message += 'You have used ' + usedGuests + ' of your 3 free guests.\\n\\n';\n      message += 'After that, additional guests are $50 each.';\n    } else {\n      message = 'You have used all 3 of your free guests this month. üòä\\n\\n';\n      message += 'Any additional guests will be $50 each.\\n\\n';\n      message += 'Your guest count resets on the 1st of next month!';\n    }\n    break;\n    \n  case 'policy':\n    const lounge = data.loungeInfo || {};\n    message = 'üìã *Policies & Fees*\\n\\n';\n    message += '*Guest Policy:*\\n';\n    message += '‚Ä¢ ' + ((lounge.GuestPolicyText || lounge.GuestPolicy || '3 free guests per month, $50 per additional guest')) + '\\n\\n';\n    message += '*Alcohol Policy:*\\n';\n    message += '‚Ä¢ Corkage fee: ' + (lounge.CorkageFeeText || lounge.CorkageFee || '$30 if bringing your own') + '\\n';\n    message += '‚Ä¢ No fee when purchasing from us\\n\\n';\n    message += 'You have ' + data.freeGuestsRemaining + ' free guest(s) remaining this month.';\n    break;\n    \n  case 'amenities':\n    message = '‚ú® *Our Amenities*\\n\\n';\n    message += '‚Ä¢ Private lounge seating\\n';\n    message += '‚Ä¢ Premium bar service\\n';\n    message += '‚Ä¢ Complimentary appetizers\\n';\n    message += '‚Ä¢ WiFi\\n';\n    message += '‚Ä¢ Music system\\n';\n    message += (Array.isArray(lounge.Amenities) ? lounge.Amenities.map(a=>'‚Ä¢ '+a).join('\\\\n') : (lounge.AmenitiesText || lounge.Amenities || '‚Ä¢ Outdoor patio'));\n    break;\n    \n  case 'contact':\n    message = 'üìç *Contact & Location*\\n\\n';\n    message += '*Address:*\\n';\n    message += (lounge.Address || lounge.Location || '123 Main Street, Suite 500, Your City, ST 12345') + '\\n\\n';\n    message += '*Phone:* ' + (lounge.Phone || lounge.PhoneNumber || '(555) 123-4567') + '\\n';\n    message += '*WhatsApp:* This number!';\n    break;\n    \n  case 'member_privacy':\n    message = \"Sorry ‚Äî I can‚Äôt confirm whether someone is a member. Member information is confidential.\";\n    break;\n\n  case 'membership_expiry':\n    {\n      const firstName = ((data.memberName || 'there').split(' ')[0]) || 'there';\n      const end = data.membershipEndDate ? new Date(data.membershipEndDate) : null;\n      const endStr = end ? end.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) : null;\n      const days = (data.daysUntilExpiry !== undefined && data.daysUntilExpiry !== null) ? Number(data.daysUntilExpiry) : null;\n      if (!endStr) {\n        message = \"I can check that for you, \" + firstName + \".\\n\\nI'm missing your membership expiry date in my records right now.\";\n      } else {\n        message = 'Your membership expires on ' + endStr + '.';\n        if (days !== null && !Number.isNaN(days)) {\n          message += '\\n\\nThat\\'s in ' + days + ' day' + (days === 1 ? '' : 's') + '.';\n        }\n      }\n    }\n    break;\n\n  case 'membership':\n    message = 'üí≥ *Membership Options*\\n\\n';\n    message += '*Monthly:* $350 + tax = $395.50/month\\n';\n    message += '*3-Month:* $1,250 + tax = $1,412.50\\n';\n    message += '   (Save $226 vs monthly!)\\n\\n';\n    message += 'Your current membership: *' + data.membershipType + '*\\n';\n    if (data.daysUntilExpiry > 0) {\n      message += 'Expires in ' + data.daysUntilExpiry + ' days\\n\\n';\n    }\n    message += 'Reply *RENEW* to renew your membership!';\n    break;\n    \n  default:\n    // For 'other' intent, mark that AI should handle it\n    message = null; // Will be handled by AI node\n    break;\n}\n\n// If we have a message, return it; otherwise mark for AI handling\nif (message !== null) {\n  if (data.isExpiringSoon && intent !== 'membership') {\n    message += '\\n\\n‚è∞ _Your membership expires in ' + data.daysUntilExpiry + ' days. Reply RENEW to extend!_';\n  }\n  \n  // For cancel_visit, set action to trigger database update\n  const action = (intent === 'cancel_visit' && cancellationAllowed === true) ? 'cancel_visit' : 'faq_response';\n  const needsPendingUpdate = (intent === 'cancel_visit' && cancellationAllowed === true);\n  \n    return [{ json: {\n    ...data,\n    action: action,\n    responseMessage: message,\n    memberId: data.memberId,\n    clearPendingData: clearPendingData,\n    savePendingGuests: (intent === 'cancel_visit' && cancellationAllowed === true)\n      ? (clearPendingData ? null : (remainingGuests !== null ? remainingGuests : undefined))\n      : undefined,\n    savePendingTime: (intent === 'cancel_visit' && cancellationAllowed === true)\n      ? (clearPendingData ? null : (remainingGuests !== null ? data.pendingTime : undefined))\n      : undefined,\n    savePendingAlcohol: (intent === 'cancel_visit' && cancellationAllowed === true)\n      ? (clearPendingData ? null : (remainingGuests !== null ? data.pendingAlcohol : undefined))\n      : undefined,\n    // For cancellation, include database update fields\n    newMonthlyGuestCount: newMonthlyGuestCount !== null ? newMonthlyGuestCount : undefined,\n    cancelledGuests: cancelledGuests > 0 ? cancelledGuests : undefined,\n    needsPendingUpdate: needsPendingUpdate,\n    cancellationAllowed: cancellationAllowed,\n    needsAI: false\n  } }];\n} else {\n  // Mark for AI handling\n    return [{ json: {\n    action: 'ai_response',\n    memberId: data.memberId,\n    needsAI: true,\n    originalMessage: data.originalMessage || '',\n    memberName: data.memberName,\n    freeGuestsRemaining: data.freeGuestsRemaining,\n    currentGuestCount: data.currentGuestCount,\n    membershipType: data.membershipType,\n    daysUntilExpiry: data.daysUntilExpiry\n  } }];\n}\n"
      },
      "id": "d47cea88-ca57-48e7-a939-4ced5bba8f32",
      "name": "Handle FAQ",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        11600,
        2384
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.needsAI}}",
              "value2": true
            }
          ]
        }
      },
      "id": "d5f0e86a-2f02-4066-8ccc-663976ff3fc3",
      "name": "Needs AI Response?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        11952,
        2224
      ]
    },
    {
      "parameters": {
        "functionCode": "// Extract AI response and merge back into original payload\nconst aiData = $json || {};\n\n// Supports OpenAI node V2 (simplify=true): { output: [ { type: 'message', content: [ { type: 'output_text', text: '...' } ] } ] }\n// Also supports older shapes as fallbacks.\nlet aiResponse = '';\n\ntry {\n  const out = aiData.output;\n  if (Array.isArray(out) && out.length > 0) {\n    const msg = out.find((x) => x && x.type === 'message') || out[0];\n    const contentArr = msg && Array.isArray(msg.content) ? msg.content : [];\n    const outText = contentArr.find((c) => c && (c.type === 'output_text' || c.type === 'text'));\n    if (outText && outText.text !== undefined) {\n      aiResponse = (typeof outText.text === 'string') ? outText.text : JSON.stringify(outText.text);\n    }\n  }\n} catch (e) {}\n\nif (!aiResponse) {\n  // legacy shapes\n  try {\n    if (aiData.choices && aiData.choices[0] && aiData.choices[0].message && aiData.choices[0].message.content) {\n      aiResponse = aiData.choices[0].message.content;\n    }\n  } catch (e) {}\n}\n\nlet original = {};\ntry {\n  original = $('Prepare AI Prompt').first().json || {};\n} catch (e) {\n  original = {};\n}\n\nconst fallback = (original._aiDraftReply || original.responseMessage || original.message || '').toString().trim();\nlet finalMsg = (aiResponse || '').toString().trim();\n\nif (!finalMsg) finalMsg = fallback || 'Thank you for your message.';\n\n// Add line breaks after sentences for WhatsApp readability\ntry {\n  finalMsg = String(finalMsg || '').trim();\n  if (finalMsg) {\n    finalMsg = finalMsg.replace(/([.!?])\\s+(?=[A-Z])/g, '$1\\n');\n    finalMsg = finalMsg.replace(/\\n{3,}/g, '\\n\\n');\n  }\n} catch (e) {}\n\nreturn [{ json: {\n  ...original,\n  responseMessage: finalMsg,\n  message: finalMsg,\n  needsAI: false,\n} }];\n"
      },
      "id": "a1a9880f-634e-4101-bc63-bacfcaa62e9c",
      "name": "Format AI Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        12272,
        2384
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{['confirm_visit','cancel_visit'].includes($json.action)}}",
              "value2": true
            }
          ]
        }
      },
      "id": "96c261ed-fbcf-4a71-b127-8b818db6bd80",
      "name": "Needs Database Update?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        11600,
        1120
      ]
    },
    {
      "parameters": {
        "functionCode": "// Clean data for Airtable - only pass updatable fields\nconst data = $json || {};\n\n// For cancellation, do NOT update TotalLifetimeGuests\nconst isCancellation = data.action === 'cancel_visit';\n\nreturn [{ json: {\n  memberId: data.memberId,\n  newMonthlyGuestCount: data.newMonthlyGuestCount,\n  newTotalLifetimeGuests: isCancellation ? undefined : (data.newTotalLifetimeGuests || data.totalLifetimeGuests || 0),\n  totalLifetimeGuests: data.totalLifetimeGuests,\n  savePendingGuests: data.savePendingGuests,\n  savePendingTime: data.savePendingTime,\n  savePendingAlcohol: data.savePendingAlcohol,\n  responseMessage: data.responseMessage,\n  message: data.message,\n  action: data.action\n} }];\n"
      },
      "id": "733ea52e-b283-48c5-bc44-8d1cf0a38ebd",
      "name": "Clean Airtable Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        11616,
        1760
      ]
    },
    {
      "parameters": {
        "operation": "update",
        "base": {
          "__rl": true,
          "value": "app8NRdp0pEHfShoJ",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "tblrq2UqWNtuZfi4j",
          "mode": "list",
          "cachedResultName": "Members",
          "cachedResultUrl": "https://airtable.com/app8NRdp0pEHfShoJ/tblrq2UqWNtuZfi4j"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{$json.memberId}}",
            "MonthlyGuestCount": "={{$json.newMonthlyGuestCount}}",
            "TotalLifetimeGuests": "={{$json.newTotalLifetimeGuests !== undefined ? $json.newTotalLifetimeGuests : $json.totalLifetimeGuests}}",
            "PendingGuests": "={{$json.savePendingGuests === null ? null : $json.savePendingGuests}}",
            "PendingTime": "={{$json.savePendingTime === null ? null : $json.savePendingTime}}",
            "PendingAlcohol": "={{$json.savePendingAlcohol === null ? null : $json.savePendingAlcohol}}"
          },
          "matchingColumns": [
            "id"
          ]
        },
        "options": {
          "typecast": true
        }
      },
      "id": "9f9dcb5f-bc13-47ad-b4e5-920d7b836169",
      "name": "Airtable: Update Member",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        11856,
        1760
      ],
      "credentials": {
        "airtableTokenApi": {
          "id": "aGJEUsnx6WBz4t50",
          "name": "Lounge Airtable"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Preserve responseMessage (and key context) after Airtable update\n// Airtable returns its own data structure, so we need to re-attach the message + action we already generated upstream.\n\nconst currentData = $json || {};\n\n// Collect upstream payloads (best-effort)\nlet faqData = {};\nlet visitData = {};\nlet memberData = {};\ntry { faqData = $('Handle FAQ').first().json || {}; } catch (e) {}\ntry { visitData = $('Process Visit Booking').first().json || {}; } catch (e) {}\ntry { memberData = $('Process Member Data').first().json || {}; } catch (e) {}\n\n// Start with Airtable output (it contains record id/fields), then fill missing values from upstream\nconst result = { ...currentData };\n\n// Preserve responseMessage\nlet responseMessage = result.responseMessage || result.message || '';\nif (!responseMessage) responseMessage = faqData.responseMessage || faqData.message || '';\nif (!responseMessage) responseMessage = visitData.responseMessage || visitData.message || '';\n\n// Fallback: scan all input items\nif (!responseMessage) {\n  try {\n    const items = $input.all() || [];\n    for (const item of items) {\n      const j = item?.json || {};\n      if (j.responseMessage && String(j.responseMessage).trim()) { responseMessage = j.responseMessage; break; }\n      if (j.message && String(j.message).trim()) { responseMessage = j.message; break; }\n    }\n  } catch (e) {}\n}\n\n// Preserve action + key fields needed downstream (AI + admin SMS)\nconst candidates = [faqData, visitData, memberData];\nfor (const src of candidates) {\n  if (!result.action && src.action) result.action = src.action;\n  if (!result.memberId && src.memberId) result.memberId = src.memberId;\n  if (!result.memberName && src.memberName) result.memberName = src.memberName;\n  if (!result.phoneNumber && src.phoneNumber) result.phoneNumber = src.phoneNumber;\n  if (result.numberOfGuests === undefined && src.numberOfGuests !== undefined) result.numberOfGuests = src.numberOfGuests;\n  if (result.cancelledGuests === undefined && src.cancelledGuests !== undefined) result.cancelledGuests = src.cancelledGuests;\n  if (result.newMonthlyGuestCount === undefined && src.newMonthlyGuestCount !== undefined) result.newMonthlyGuestCount = src.newMonthlyGuestCount;\n  if (result.totalFees === undefined && src.totalFees !== undefined) result.totalFees = src.totalFees;\n  if (!result.visitDate && src.visitDate) result.visitDate = src.visitDate;\n  if (!result.visitTime && src.visitTime) result.visitTime = src.visitTime;\n  if (!result.alcoholSource && src.alcoholSource) result.alcoholSource = src.alcoholSource;\n}\n\n// Ensure memberId exists (Airtable returns record id in result.id)\nif (!result.memberId && result.id) result.memberId = result.id;\n\nif (!responseMessage || String(responseMessage).trim() === '') {\n  responseMessage = 'Thank you for your message. Your request has been processed.';\n}\n\nresult.responseMessage = responseMessage;\nresult.message = responseMessage;\n\nreturn [{ json: result }];\n"
      },
      "id": "bda42572-e344-40c8-90dd-91038183c391",
      "name": "Preserve Response Message",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        11968,
        1392
      ]
    },
    {
      "parameters": {
        "functionCode": "// BULLETPROOF: Always ensure responseMessage exists\nconst data = $json || {};\n\nfunction normalizeToE164(raw) {\n  const s = String(raw || '').trim();\n  if (!s) return '';\n  const noPrefix = s.startsWith('whatsapp:') ? s.slice('whatsapp:'.length).trim() : s;\n  const m = noPrefix.match(/\\+\\d{10,15}/);\n  if (m) return m[0];\n  const digits = noPrefix.replace(/[^0-9]/g, '');\n  if (!digits) return '';\n  if (digits.length === 11 && digits.startsWith('1')) return '+' + digits;\n  if (digits.length === 10) return '+1' + digits;\n  if (digits.length >= 10 && digits.length <= 15) return '+' + digits;\n  return '';\n}\n\n// Get responseMessage from current data\nlet msg = data.responseMessage || data.message || '';\n\n// If empty, search through all input items\nif (!msg || msg.trim() === '') {\n  try {\n    const items = $input.all();\n    for (const item of items) {\n      const json = item.json || {};\n      if (json.responseMessage && json.responseMessage.trim() !== '') {\n        msg = json.responseMessage;\n        break;\n      }\n      if (json.message && json.message.trim() !== '') {\n        msg = json.message;\n        break;\n      }\n    }\n  } catch (e) {\n    // Ignore errors\n  }\n}\n\n// If still empty, try node references\nif (!msg || msg.trim() === '') {\n  try {\n    const visitData = $('Process Visit Booking').first().json || {};\n    msg = visitData.responseMessage || visitData.message || '';\n  } catch (e) {}\n}\n\nif (!msg || msg.trim() === '') {\n  try {\n    const faqData = $('Handle FAQ').first().json || {};\n    msg = faqData.responseMessage || faqData.message || '';\n  } catch (e) {}\n}\n\n// ABSOLUTE FALLBACK - always return something\nif (!msg || msg.trim() === '') {\n  msg = 'Thank you for your message. Your request has been received.';\n}\n\n// Ensure it's a string and not empty\nmsg = String(msg).trim();\nif (msg === '') {\n  msg = 'Thank you for your message.';\n}\n\n// Return with BOTH fields to ensure compatibility\nconst result = {\n  ...data,\n  _originalPhone: normalizeToE164(data._originalPhone || data.phoneNumber || data.to || data.from || ''),\n  responseMessage: msg,\n  message: msg\n};\n\n// Double-check - if somehow still empty, force a message\nif (!result.responseMessage || result.responseMessage.trim() === '') {\n  result.responseMessage = 'Thank you for your message.';\n  result.message = 'Thank you for your message.';\n}\n\nreturn [{ json: result }];\n"
      },
      "id": "cfc38f11-04bf-49b6-ab85-d0ecd96cbc1d",
      "name": "Ensure Message",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        12192,
        1760
      ]
    },
    {
      "parameters": {
        "from": "whatsapp:+12898135672",
        "to": "={{'whatsapp:' + $json.phoneNumber}}",
        "message": "={{$json.responseMessage || $json.message || 'Thank you for your message.'}}",
        "options": {}
      },
      "id": "774d7068-e8e5-4185-aa54-591101b60693",
      "name": "WhatsApp: Send Response",
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        12048,
        1968
      ],
      "credentials": {
        "twilioApi": {
          "id": "pjAFO4uh7n4T1yi5",
          "name": "WhatsAPP Twilio"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": \"success\", \"message\": \"Message processed\" } }}",
        "options": {}
      },
      "id": "5d64020f-b046-4afe-98e0-390ae0d79139",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        12272,
        1968
      ]
    },
    {
      "parameters": {
        "operation": "update",
        "base": {
          "__rl": true,
          "value": "app8NRdp0pEHfShoJ",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "tblrq2UqWNtuZfi4j",
          "mode": "list",
          "cachedResultName": "Members",
          "cachedResultUrl": "https://airtable.com/app8NRdp0pEHfShoJ/tblrq2UqWNtuZfi4j"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{$json.memberId}}",
            "PendingGuests": "={{$json.savePendingGuests}}",
            "PendingTime": "={{$json.savePendingTime}}",
            "PendingAlcohol": "={{$json.savePendingAlcohol}}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "readOnly": true,
              "removed": false
            },
            {
              "id": "MemberID",
              "displayName": "MemberID",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": true,
              "removed": false
            },
            {
              "id": "FullName",
              "displayName": "FullName",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "PhoneNumber",
              "displayName": "PhoneNumber",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Email",
              "displayName": "Email",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "MembershipType",
              "displayName": "MembershipType",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "options",
              "options": [
                {
                  "name": "Monthly",
                  "value": "Monthly"
                },
                {
                  "name": "3-Month",
                  "value": "3-Month"
                }
              ],
              "readOnly": false,
              "removed": false
            },
            {
              "id": "MembershipStatus",
              "displayName": "MembershipStatus",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "options",
              "options": [
                {
                  "name": "Active",
                  "value": "Active"
                },
                {
                  "name": "Suspended",
                  "value": "Suspended"
                },
                {
                  "name": "Expired",
                  "value": "Expired"
                },
                {
                  "name": "Cancelled",
                  "value": "Cancelled"
                }
              ],
              "readOnly": false,
              "removed": false
            },
            {
              "id": "MembershipStartDate",
              "displayName": "MembershipStartDate",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "MembershipEndDate",
              "displayName": "MembershipEndDate",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "MembershipPrice",
              "displayName": "MembershipPrice",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "AutoRenew",
              "displayName": "AutoRenew",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "MonthlyGuestCount",
              "displayName": "MonthlyGuestCount",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "LastResetDate",
              "displayName": "LastResetDate",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "TotalLifetimeGuests",
              "displayName": "TotalLifetimeGuests",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "JoinDate",
              "displayName": "JoinDate",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "RenewalReminderSent",
              "displayName": "RenewalReminderSent",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "options",
              "options": [
                {
                  "name": "None",
                  "value": "None"
                },
                {
                  "name": "7-Day",
                  "value": "7-Day"
                },
                {
                  "name": "3-Day",
                  "value": "3-Day"
                },
                {
                  "name": "1-day",
                  "value": "1-day"
                },
                {
                  "name": "Expired",
                  "value": "Expired"
                }
              ],
              "readOnly": false,
              "removed": false
            },
            {
              "id": "LastReminderDate",
              "displayName": "LastReminderDate",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "CancellationDate",
              "displayName": "CancellationDate",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "CancellationReason",
              "displayName": "CancellationReason",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Notes",
              "displayName": "Notes",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Visits",
              "displayName": "Visits",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "array",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "MembershipTransactions",
              "displayName": "MembershipTransactions",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "array",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "PendingGuests",
              "displayName": "PendingGuests",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "PendingTime",
              "displayName": "PendingTime",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "PendingAlcohol",
              "displayName": "PendingAlcohol",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "LastMessageAt",
              "displayName": "LastMessageAt",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {
          "typecast": true
        }
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        11296,
        1456
      ],
      "id": "0d022813-d0df-4237-8905-cf3b18104ed6",
      "name": "Save Pending Visit Data",
      "credentials": {
        "airtableTokenApi": {
          "id": "aGJEUsnx6WBz4t50",
          "name": "Lounge Airtable"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.action}}",
              "value2": "cancel_visit"
            }
          ]
        }
      },
      "id": "38dbd286-4ffc-48f4-8d36-3eab949ae8ad",
      "name": "Is Cancel Visit?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        11712,
        2624
      ]
    },
    {
      "parameters": {
        "functionCode": "// Prepare a single prompt for OpenAI for EVERY outbound reply.\n// - If responseMessage exists: rewrite it to sound more human (keep facts unchanged)\n// - Else: generate a natural answer using member context + lounge info\n\nconst data = $json || {};\n\nconst draft = (data.responseMessage || data.message || '').toString();\nconst hasDraft = draft.trim().length > 0;\n\nconst memberName = (((data.memberName || '').toString().trim().split(' ')[0]) || '').trim() || 'there';\nconst originalMessage = (data.originalMessage || data.originalMessageText || data._originalMessage || '').toString();\n\nconst facts = {\n  action: data.action,\n  memberName: data.memberName,\n  membershipType: data.membershipType,\n  membershipStatus: data.membershipStatus,\n  daysUntilExpiry: data.daysUntilExpiry,\n  freeGuestsRemaining: data.freeGuestsRemaining,\n  currentGuestCount: data.currentGuestCount,\n  totalLifetimeGuests: data.totalLifetimeGuests,\n\n  // Visit / billing facts (when available)\n  numberOfGuests: data.numberOfGuests,\n  freeGuestsUsed: data.freeGuestsUsed,\n  paidGuestsCount: data.paidGuestsCount,\n  guestFee: data.guestFee,\n  alcoholSource: data.alcoholSource,\n  corkageFee: data.corkageFee,\n  totalFees: data.totalFees,\n  visitDate: data.visitDate,\n  visitTime: data.visitTime,\n\n  // Cancellation facts (when available)\n  cancelledGuests: data.cancelledGuests,\n  newMonthlyGuestCount: data.newMonthlyGuestCount,\n\n  // Pending visit state (when available)\n  pendingGuests: data.pendingGuests,\n  pendingTime: data.pendingTime,\n  pendingAlcohol: data.pendingAlcohol,\n};\n\nconst lounge = data.loungeInfo || {};\n\nconst hoursLine =\n  lounge.HoursText || lounge.Hours || lounge.hours ||\n  'Hours not available right now.';\n\nconst guestPolicyLine =\n  lounge.GuestPolicyText || lounge.GuestPolicy || lounge.guestPolicy ||\n  '3 free guests per month, $50 per additional guest';\n\nconst corkageLine =\n  lounge.CorkageFeeText || lounge.CorkageFee || lounge.Corkage || lounge.corkageFee ||\n  '$30 if bringing own alcohol';\n\nconst addressLine =\n  lounge.Address || lounge.Location || lounge.address ||\n  '123 Main Street, Suite 500, Your City, ST 12345';\n\nconst phoneLine =\n  lounge.Phone || lounge.PhoneNumber || lounge.phone ||\n  '(555) 123-4567';\n\nconst amenitiesLine =\n  (Array.isArray(lounge.Amenities) ? lounge.Amenities.join(', ') : (lounge.Amenities || lounge.amenities)) ||\n  'Private lounge seating, premium bar service, complimentary appetizers, WiFi, music system, outdoor patio';\n\nconst loungeInfo =\n  'LOUNGE INFORMATION\\n' +\n  '- Hours: ' + hoursLine + '\\n' +\n  '- Guest Policy: ' + guestPolicyLine + '\\n' +\n  '- Corkage Fee: ' + corkageLine + '\\n' +\n  '- Address: ' + addressLine + '\\n' +\n  '- Phone: ' + phoneLine + '\\n' +\n  '- Amenities: ' + amenitiesLine;\n\nconst loungeInfoJson = JSON.stringify(lounge, null, 2);\n\nlet aiPrompt = '';\n\nif (hasDraft) {\n  aiPrompt =\n    'TASK: Rewrite the DRAFT_REPLY below so it sounds like a real human WhatsApp concierge.\\n\\n' +\n    'Rules:\\n' +\n    '- Keep ALL facts, numbers, fees, dates, and policies EXACTLY the same.\\n' +\n    '- Do NOT add new policies or make up details.\\n' +\n    '- Keep it concise (1-6 short lines).\\n' +\n    '- Put each sentence on its own line (use line breaks).\\n' +\n    '- If the member asked about hours/open/close, keep the Hours line from LOUNGE INFORMATION (do not drop it).\\n' +\n    '- Avoid sounding robotic.\\n' +\n    '- Output ONLY the final message text (no labels).\\n\\n' +\n    'Member name: ' + memberName + '\\n\\n' +\n    loungeInfo + '\\n\\n' +\n    'LOUNGE_INFO_JSON:\\n' + loungeInfoJson + '\\n\\n' +\n    'FACTS_JSON:\\n' + JSON.stringify(facts, null, 2) + '\\n\\n' +\n    'DRAFT_REPLY:\\n' + draft;\n} else {\n  aiPrompt =\n    'TASK: Reply to the member naturally and helpfully.\\n\\n' +\n    'Rules:\\n' +\n    '- Use FACTS_JSON and LOUNGE INFORMATION only.\\n' +\n    '- If something required is missing, ask ONE clear follow-up question.\\n' +\n    '- Keep it concise (1-6 short lines).\\n' +\n    '- Put each sentence on its own line (use line breaks).\\n' +\n    '- Output ONLY the final message text (no labels).\\n\\n' +\n    'Member name: ' + memberName + '\\n\\n' +\n    loungeInfo + '\\n\\n' +\n    'LOUNGE_INFO_JSON:\\n' + loungeInfoJson + '\\n\\n' +\n    'FACTS_JSON:\\n' + JSON.stringify(facts, null, 2) + '\\n\\n' +\n    'MEMBER_MESSAGE:\\n' + originalMessage;\n}\n\nreturn [{ json: {\n  ...data,\n  aiPrompt,\n  _aiHadDraft: hasDraft,\n  _aiDraftReply: draft,\n} }];\n"
      },
      "id": "0d981de4-a5d7-4047-b61d-f0fcd76269c4",
      "name": "Prepare AI Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        11872,
        2464
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{['confirm_visit','cancel_visit','renewal_request'].includes(String($json.action || '').trim())}}",
              "value2": true
            }
          ]
        }
      },
      "id": "d639b3c6-4e78-4f55-a43f-bb341afb3ece",
      "name": "Notify Admins?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        12512,
        2384
      ]
    },
    {
      "parameters": {
        "functionCode": "// Build SMS notifications for admins.\n// This node should ALWAYS output 1 item per admin number when it is executed.\n// NOTE: Make sure your numbers are in E.164 format, e.g. +16475551234\n\nconst data = $json || {};\n\nconst adminNumbers = [\n  '+16472032776',\n  '+16478782776',\n  '+10000000003',\n];\n\n// Normalize admin numbers: allow accidental \"whatsapp:+...\" inputs\nfunction normalizeToE164(n) {\n  const s = String(n || '').trim();\n  if (!s) return '';\n  return s.startsWith('whatsapp:') ? s.slice('whatsapp:'.length).trim() : s;\n}\n\n// Determine action (prefer explicit action; otherwise infer from available fields)\nlet action = String(data.action || '').trim();\nif (!action) {\n  const looksLikeConfirm =\n    data.numberOfGuests !== undefined && data.numberOfGuests !== null ||\n    data.totalFees !== undefined && data.totalFees !== null ||\n    data.guestFee !== undefined && data.guestFee !== null;\n\n  const looksLikeCancel =\n    data.cancelledGuests !== undefined && data.cancelledGuests !== null ||\n    data.newMonthlyGuestCount !== undefined && data.newMonthlyGuestCount !== null;\n\n  if (looksLikeConfirm) action = 'confirm_visit';\n  else if (looksLikeCancel) action = 'cancel_visit';\n}\n\nconst memberName = String(data.memberName || '').trim();\nconst memberPhone = data.phoneNumber || data._originalPhone || '';\n\nconst memberDisplayName = (memberName && !['there','member'].includes(memberName.toLowerCase())) ? memberName : (memberPhone || 'Member');\n\nlet header = '[Black Dragon Lounge] ';\nif (action === 'confirm_visit') header += 'Reservation confirmed';\nelse if (action === 'cancel_visit') header += 'Reservation updated (cancellation)';\nelse if (action === 'renewal_request') header += 'Membership renewal request';\nelse header += 'Member update';\n\nconst visitDate = data.visitDate ? String(data.visitDate).slice(0, 10) : '';\nconst visitTime = data.visitTime || data.timeReference || '';\n\nconst details = [];\nconst memberLine = (!memberPhone || memberDisplayName === memberPhone)\n  ? ('Member: ' + memberDisplayName)\n  : ('Member: ' + memberDisplayName + ' (' + memberPhone + ')');\ndetails.push(memberLine);\n\nif (action === 'confirm_visit') {\n  if (data.numberOfGuests !== undefined && data.numberOfGuests !== null) details.push('Guests: ' + data.numberOfGuests);\n  if (visitDate || visitTime) details.push('When: ' + [visitDate, visitTime].filter(Boolean).join(' '));\n  if (data.alcoholSource) details.push('Alcohol: ' + data.alcoholSource);\n  if (data.totalFees !== undefined && data.totalFees !== null) details.push('Total: $' + data.totalFees);\n}\n\nif (action === 'cancel_visit') {\n  if (data.cancelledGuests !== undefined && data.cancelledGuests !== null) details.push('Cancelled guests: ' + data.cancelledGuests);\n  if (data.newMonthlyGuestCount !== undefined && data.newMonthlyGuestCount !== null) details.push('New monthly guest count: ' + data.newMonthlyGuestCount);\n}\n\nconst memberFacing = (data.responseMessage || data.message || '').toString().trim();\n\nconst adminMsg = [\n  header,\n  ...details,\n  memberFacing ? ('\\nMember message sent:\\n' + memberFacing) : '',\n].filter(Boolean).join('\\n');\n\nconst items = (adminNumbers || [])\n  .map((n) => normalizeToE164(n))\n  .filter((n) => n.length > 0)\n  .map((to) => ({ json: { to, message: adminMsg } }));\n\nreturn items;\n"
      },
      "id": "b2ca9321-d6d5-4b2f-9010-7bb52f97c282",
      "name": "Build Admin SMS",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        12736,
        2368
      ]
    },
    {
      "parameters": {
        "from": "whatsapp:+12898135672",
        "to": "={{'whatsapp:' + $json.to}}",
        "message": "={{ $json.message }}",
        "options": {}
      },
      "id": "1b2ef090-d6d0-468b-b8d7-8b6fa5e83ec4",
      "name": "Admin SMS: Send",
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        12960,
        2368
      ],
      "credentials": {
        "twilioApi": {
          "id": "pjAFO4uh7n4T1yi5",
          "name": "WhatsAPP Twilio"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "modelId": {
          "mode": "id",
          "value": "gpt-4o-mini"
        },
        "responses": {
          "values": [
            {
              "role": "system",
              "content": "You are the Black Dragon Lounge WhatsApp concierge. Rewrite drafts to sound natural and human. Keep facts and numbers exact. No emojis. No headings or labels (avoid 'Hours:' / 'Our Hours'). Never output placeholders or templates like {OPEN_TIME}/{CLOSE_TIME} or any curly-brace text. Do not change the timeframe words (today/tonight/tomorrow) from the draft. Do not mention 'closed right now' unless the member asked about right now/today/tonight. If the draft includes an opening time and closing time for the relevant day, you may combine them into one sentence (using the actual times from the draft). Output only the final message text. Use line breaks between sentences (each sentence on its own line). If the member is just acknowledging (e.g. thanks/see you), respond briefly and do not restate hours/policies."
            },
            {
              "content": "={{$json.aiPrompt}}"
            }
          ]
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 220,
          "temperature": 0.9
        }
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 2.1,
      "position": [
        12080,
        2640
      ],
      "id": "75107a13-f517-4db9-8abb-0fde7f8629eb",
      "name": "OpenAI: Generate Natural Response1",
      "credentials": {
        "openAiApi": {
          "id": "dayK5M2xldgIkgc7",
          "name": "OpenAI GPT-4"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "authentication": "airtableTokenApi",
        "operation": "list",
        "application": {
          "__rl": true,
          "mode": "",
          "value": "app8NRdp0pEHfShoJ"
        },
        "table": "LoungeInfo",
        "additionalOptions": {}
      },
      "id": "719dd5e5-a1d3-4631-b374-2e63339a2232",
      "name": "Airtable: Lookup Lounge Info",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 1,
      "position": [
        8960,
        1984
      ],
      "credentials": {
        "airtableTokenApi": {
          "id": "aGJEUsnx6WBz4t50",
          "name": "Lounge Airtable"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Build a strict JSON-only routing prompt for the AI intent router.\nconst data = $json || {};\n\nconst message =\n  (data.originalMessageText || data._originalMessage || data.originalMessage || '').toString().trim();\n\nconst context = {\n  message,\n  memberName: data.memberName,\n  membershipStatus: data.membershipStatus,\n  membershipType: data.membershipType,\n  membershipEndDate: data.membershipEndDate,\n  daysUntilExpiry: data.daysUntilExpiry,\n  freeGuestsRemaining: data.freeGuestsRemaining,\n  currentGuestCount: data.currentGuestCount,\n  pendingGuests: data.pendingGuests,\n  pendingTime: data.pendingTime,\n  pendingAlcohol: data.pendingAlcohol,\n  loungeInfo: data.loungeInfo,\n};\n\nconst system =\n  \"You are an intent router for a WhatsApp concierge workflow.\\n\\n\" +\n  \"Return ONLY valid JSON (no markdown, no extra text).\\n\\n\" +\n  \"Choose intent from this exact list:\\n\" +\n  \"[\\n\" +\n  \"  \\\"visit\\\",\\n\" +\n  \"  \\\"cancel_visit\\\",\\n\" +\n  \"  \\\"booking_query\\\",\\n\" +\n  \"  \\\"hours_query\\\",\\n\" +\n  \"  \\\"guest_count_query\\\",\\n\" +\n  \"  \\\"membership_expiry\\\",\\n\" +\n  \"  \\\"membership\\\",\\n\" +\n  \"  \\\"contact\\\",\\n\" +\n  \"  \\\"amenities\\\",\\n\" +\n  \"  \\\"policy\\\",\\n\" +\n  \"  \\\"closing\\\",\\n\" +\n  \"  \\\"greeting\\\",\\n\" +\n  \"  \\\"other\\\"\\n\" +\n  \"]\\n\\n\" +\n  \"Rules:\\n\" +\n  \"- If the user asks about membership expiry/end date, use \\\"membership_expiry\\\".\\n\" +\n  \"- If the user asks about an existing booking (do I have a booking / what time), use \\\"booking_query\\\".\\n\" +\n  \"- If the user mentions bringing a number of guests (e.g. 'bring 4 guests' / 'with 4 guests'), treat it as \\\"visit\\\" (even if they say 'when I come').\\n\" +\n  \"- If the user asks about hours/open/close, use \\\"hours_query\\\".\\n\" +\n  \"- If guests cancelled but member is still coming, use \\\"cancel_visit\\\" and entities.cancel_mode=\\\"guests\\\".\\n\" +\n  \"- If member cancels whole visit (can't come / cancel my visit), use \\\"cancel_visit\\\" and entities.cancel_mode=\\\"visit\\\".\\n\" +\n  \"- If unsure, use intent \\\"other\\\" and confidence <= 0.49.\\n\\n\" +\n  \"Output JSON with this exact shape:\\n\" +\n  \"{\\n\" +\n  \"  \\\"intent\\\": \\\"<one of the list>\\\",\\n\" +\n  \"  \\\"confidence\\\": 0.0,\\n\" +\n  \"  \\\"entities\\\": {\\n\" +\n  \"    \\\"guests\\\": null,\\n\" +\n  \"    \\\"cancelledGuests\\\": null,\\n\" +\n  \"    \\\"cancel_mode\\\": null,\\n\" +\n  \"    \\\"timeReference\\\": null,\\n\" +\n  \"    \\\"alcohol\\\": null,\\n\" +\n  \"    \\\"asks_about_tomorrow\\\": null\\n\" +\n  \"  },\\n\" +\n  \"  \\\"followUpQuestion\\\": null\\n\" +\n  \"}\\n\";\n\nconst user =\n  \"CONTEXT_JSON:\\n\" +\n  JSON.stringify(context, null, 2);\n\nreturn [{ json: { ...data, routerSystem: system, routerPrompt: user } }];"
      },
      "id": "b66a003d-4386-4718-be70-9bb8b3fdfb8d",
      "name": "Prepare Intent Router Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        10752,
        2224
      ]
    },
    {
      "parameters": {
        "modelId": {
          "mode": "id",
          "value": "gpt-4o-mini"
        },
        "responses": {
          "values": [
            {
              "role": "system",
              "content": "={{$json.routerSystem}}"
            },
            {
              "content": "={{$json.routerPrompt}}"
            }
          ]
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 280,
          "temperature": 0.1
        }
      },
      "id": "b98f7f06-8831-4b96-b619-d8a4eb0e3a67",
      "name": "OpenAI: Intent Router",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 2.1,
      "position": [
        10176,
        2656
      ],
      "credentials": {
        "openAiApi": {
          "id": "dayK5M2xldgIkgc7",
          "name": "OpenAI GPT-4"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "functionCode": "// Parse AI router JSON output and merge back into original payload.\nconst aiData = $json || {};\n\nlet raw = '';\ntry {\n  const out = aiData.output;\n  if (Array.isArray(out) && out.length > 0) {\n    const msg = out.find((x) => x && x.type === 'message') || out[0];\n    const contentArr = msg && Array.isArray(msg.content) ? msg.content : [];\n    const outText = contentArr.find((c) => c && (c.type === 'output_text' || c.type === 'text' || c.type === 'output_text') && c.text !== undefined)\n      || contentArr.find((c) => c && c.text !== undefined);\n    if (outText && outText.text !== undefined) raw = String(outText.text);\n  }\n} catch (e) {}\n\nraw = String(raw || '').trim();\n\nlet parsed = null;\ntry { parsed = JSON.parse(raw); } catch (e) { parsed = null; }\n\nlet original = {};\ntry { original = $('Prepare Intent Router Prompt').first().json || {}; } catch (e) { original = {}; }\n\nconst ai_intent = parsed && parsed.intent ? String(parsed.intent) : 'other';\nconst ai_confidence = parsed && parsed.confidence !== undefined ? Number(parsed.confidence) : 0;\nconst ai_entities = (parsed && parsed.entities && typeof parsed.entities === 'object') ? parsed.entities : {};\nconst followUpQuestion = parsed && parsed.followUpQuestion ? String(parsed.followUpQuestion) : null;\n\nreturn [{ json: {\n  ...original,\n  ai_router_raw: raw,\n  ai_intent,\n  ai_confidence: Number.isFinite(ai_confidence) ? ai_confidence : 0,\n  ai_entities,\n  ai_followUpQuestion: followUpQuestion,\n} }];"
      },
      "id": "e4c5a8c8-338c-42a3-bf25-4de32c0ddc48",
      "name": "Parse Intent Router",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        10624,
        2656
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{Number($json.ai_confidence || 0) >= 0.7}}",
              "value2": true
            }
          ]
        }
      },
      "id": "4fa6ba40-4abf-4e14-bb76-281ad6e8b953",
      "name": "Use AI Router?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        11328,
        2656
      ]
    },
    {
      "parameters": {
        "functionCode": "// Map AI router intent/entities into the fields expected by the workflow.\nconst data = $json || {};\nconst entities = (data.ai_entities && typeof data.ai_entities === 'object') ? data.ai_entities : {};\n\nlet intent = String(data.ai_intent || 'other').trim();\n\nconst msgRaw = (data.originalMessageText || data._originalMessage || data.originalMessage || '').toString();\nconst msgLower = msgRaw.toLowerCase();\n\n// Privacy override: don't disclose other members\nconst selfMemberQuery = /\\b(am i|i\\s*am|i\\s*'m|is\\s+my|my\\s+membership|my\\s+member|my\\s+status|are\\s+you|your\\s+membership|you\\s+a\\s+member)\\b/i.test(msgLower);\nconst thirdPartyMemberQuery = !selfMemberQuery && (\n  /\\b(is|are)\\s+[a-z][a-z'\\-]+(?:\\s+[a-z][a-z'\\-]+){0,3}\\s+(an?\\s+)?members?\\b/i.test(msgLower) ||\n  /\\b(is|are)\\s+(he|she|they)\\s+(an?\\s+)?members?\\b/i.test(msgLower) ||\n  /\\bwho\\s+(is|are)\\s+(a\\s+)?members?\\b/i.test(msgLower) ||\n  /\\blist\\s+(all\\s+)?members\\b/i.test(msgLower) ||\n  (/\\bcan\\s+you\\s+(tell|confirm|check)\\b/i.test(msgLower) && /\\bmember(ship)?\\b/i.test(msgLower) && /\\b(he|she|they|someone|anyone)\\b/i.test(msgLower))\n);\nif (thirdPartyMemberQuery) {\n  intent = 'member_privacy';\n}\n\n\nlet guests = (entities.guests !== undefined && entities.guests !== null && !Number.isNaN(Number(entities.guests)))\n  ? Number(entities.guests)\n  : null;\n\n// If AI didn't extract guests, infer from message.\nif (guests === null) {\n  const gm =\n    msgLower.match(/(?:bring(?:ing)?|with)\\s+(\\d+)\\s*(?:more\\s*)?(?:guests?|people|friends?)\\b/) ||\n    msgLower.match(/\\b(\\d+)\\s*(?:guests?|people|friends?)\\b/);\n  if (gm && gm[1] && !Number.isNaN(Number(gm[1]))) {\n    guests = Number(gm[1]);\n  }\n}\n\n// Safety override: avoid routing \"when I come\" guest messages into hours.\nconst hasGuestSignal = (guests !== null) || /\\bguest(s)?\\b/.test(msgLower) || /\\bbring\\b/.test(msgLower);\nconst hasHoursSignal = /\\b(hours?|open|close|closing|what time|when do you open|are you open)\\b/.test(msgLower);\n\nif ((intent === 'hours_query' || intent === 'other') && hasGuestSignal && !hasHoursSignal) {\n  intent = 'visit';\n}\n\nconst alcoholRaw = entities.alcohol !== undefined && entities.alcohol !== null ? String(entities.alcohol).toLowerCase().trim() : '';\nconst alcohol = (alcoholRaw === 'own' || alcoholRaw === 'purchase') ? alcoholRaw : null;\n\nconst timeReference = entities.timeReference !== undefined && entities.timeReference !== null\n  ? String(entities.timeReference).trim()\n  : null;\n\nconst originalMessage = msgLower.trim();\n\nreturn [{ json: {\n  ...data,\n  intent,\n  guests,\n  alcohol,\n  timeReference,\n  originalMessage,\n  // keep existing behavior\n  needsAI: intent === 'other' || intent === 'hours_query' || intent === 'guest_count_query',\n} }];"
      },
      "id": "74de4547-d469-4622-9ada-65b790a6ccfa",
      "name": "Apply AI Intent",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        11664,
        1968
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "WhatsApp Webhook": {
      "main": [
        [
          {
            "node": "Parse Incoming Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Incoming Message": {
      "main": [
        [
          {
            "node": "Save Message Branch",
            "type": "main",
            "index": 0
          },
          {
            "node": "Airtable: Lookup Member",
            "type": "main",
            "index": 0
          },
          {
            "node": "Airtable: Lookup Lounge Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Message Branch": {
      "main": [
        [
          {
            "node": "Merge Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Airtable: Lookup Member": {
      "main": [
        [
          {
            "node": "Merge Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Data": {
      "main": [
        [
          {
            "node": "Merge Lounge Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Member Result": {
      "main": [
        [
          {
            "node": "Member Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Member Found?": {
      "main": [
        [
          {
            "node": "Not Member Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process Member Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Not Member Response": {
      "main": [
        [
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Member Data": {
      "main": [
        [
          {
            "node": "Check Quick Command",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Quick Command": {
      "main": [
        [
          {
            "node": "Is RENEW?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is RENEW?": {
      "main": [
        [
          {
            "node": "Handle RENEW",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is CANCEL?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle RENEW": {
      "main": [
        [
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is CANCEL?": {
      "main": [
        [
          {
            "node": "Handle CANCEL",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is Active?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle CANCEL": {
      "main": [
        [
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Active?": {
      "main": [
        [
          {
            "node": "Handle Inactive Member",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Intent Router Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Inactive Member": {
      "main": [
        [
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Classify Intent": {
      "main": [
        [
          {
            "node": "Is Visit?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Visit?": {
      "main": [
        [
          {
            "node": "Process Visit Booking",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is Confirm Cancel?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Visit Booking": {
      "main": [
        [
          {
            "node": "Needs Database Update?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Database Update?": {
      "main": [
        [
          {
            "node": "Clean Airtable Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Save Pending Visit Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Airtable: Update Member": {
      "main": [
        [
          {
            "node": "Preserve Response Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Airtable Data": {
      "main": [
        [
          {
            "node": "Airtable: Update Member",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preserve Response Message": {
      "main": [
        [
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure Message": {
      "main": [
        [
          {
            "node": "WhatsApp: Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Confirm Cancel?": {
      "main": [
        [
          {
            "node": "Handle Confirm Cancel",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle FAQ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Confirm Cancel": {
      "main": [
        [
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle FAQ": {
      "main": [
        [
          {
            "node": "Is Cancel Visit?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs AI Response?": {
      "main": [
        [
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format AI Response": {
      "main": [
        [
          {
            "node": "Ensure Message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Notify Admins?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Notify Admins?": {
      "main": [
        [
          {
            "node": "Build Admin SMS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Admin SMS": {
      "main": [
        [
          {
            "node": "Admin SMS: Send",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "WhatsApp: Send Response": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Cancel Visit?": {
      "main": [
        [
          {
            "node": "Needs Database Update?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Needs AI Response?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Save Pending Visit Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare AI Prompt": {
      "main": [
        [
          {
            "node": "OpenAI: Generate Natural Response1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI: Generate Natural Response1": {
      "main": [
        [
          {
            "node": "Format AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Intent Router Prompt": {
      "main": [
        [
          {
            "node": "OpenAI: Intent Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI: Intent Router": {
      "main": [
        [
          {
            "node": "Parse Intent Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Intent Router": {
      "main": [
        [
          {
            "node": "Use AI Router?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use AI Router?": {
      "main": [
        [
          {
            "node": "Apply AI Intent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Classify Intent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply AI Intent": {
      "main": [
        [
          {
            "node": "Is Visit?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Airtable: Lookup Lounge Info": {
      "main": [
        [
          {
            "node": "Merge Lounge Info",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Lounge Info": {
      "main": [
        [
          {
            "node": "Check Member Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false,
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "068d50cf-7868-4794-9577-681e38fd3d08",
  "meta": {
    "instanceId": "ff9144574abd4060eb276caf6fde5475cd7b8818811aedc6829939465ad929a2"
  },
  "id": "m-KDFHoh5KC29Vwcl2Mco",
  "tags": []
}